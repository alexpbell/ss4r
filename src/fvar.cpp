/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
#if defined(__GNUC__) && (__GNUC__ < 3)
  #pragma implementation "fvar.h"
#endif
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
@file
@author David Fournier
@copyright Copyright (c) 2008-2020 Regents of the University of California

@brief Functions for dvar_vector to find max(const dvar_vector&) and min(const dvar_vector&).
*/

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Dot-product fpor dvar_vector and sum for dvar_vector and dvar_matrix.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
@file
@author David Fournier
@copyright Copyright (c) 2008-2020 Regents of the University of California

@brief Assignment operators for dvar_vector for types dvar_vector, prevariable and double
*/
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
@file
@author David Fournier
@copyright Copyright (c) 2008-2020 Regents of the University of California

@brief Functions for dvar_vector to compute sin, ...
*/
/**
@file
@author David Fournier
@copyright Copyright (c) 2008-2020 Regents of the University of California

@brief Unary functions for dvar_vector operator-= and operator+=
*/
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
@file
@author David Fournier
@copyright Copyright (c) 2008-2020 Regents of the University of California

@brief AD Function operator/(const dvar_vector&, const double)
*/
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
@file
@author David Fournier
@copyright Copyright (c) 2008-2020 Regents of the University of California

@brief Function operator-(const dvar_vector&, const double)
*/
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/**
@file
@author David Fournier
@copyright Copyright (c) 2008-2020 Regents of the University of California

@brief Member functions dvar_vector::elem_div for various types.
*/

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar_fn.cpp
// math.h functions involving prevariables
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
Author: David Fournier
Copyright (c) 2008-2012 Regents of the University of California
*/

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 \file
 Overloads of math library functions for variable arguments.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 \file
  More overloads of math library functions for variable arguments.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar_fn.cpp
// math.h functions involving prevariables
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// constructors, destructors and misc functions involving class prevariable

/**
 * $Id: fvar_m15.cpp 789 2010-10-05 01:01:09Z johnoel $
 *
 * Author: David Fournier
 * Copyright (c) 2009-2012 ADMB Foundation
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/**
 * $Id: fvar_m20.cpp 789 2010-10-05 01:01:09Z johnoel $
 *
 * Author: Steve Martell made Changes on Dec 30, 2013
 *
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
 * $Id: fvar_m24.cpp 789 2010-10-05 01:01:09Z johnoel $
 *
 * Author: Unknown
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/**
\file
Author: David Fournier
Copyright (c) 2008-2012 Regents of the University of California
*/
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class dvariable

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class dvariable

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class prevariable

/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
// file fvar.cpp
// constructors, destructors and misc functions involving class dvariable

/**
Author: David Fournier
Copyright (c) 2008-2012 Regents of the University of California
*/
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
 * $Id: fvar_m42.cpp 789 2010-10-05 01:01:09Z johnoel $
 *
 * Author: David Fournier
 * Copyright (c) 2009-2012 ADMB Foundation
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/**
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
/*
 * $Id$
 *
 * Author: David Fournier
 * Copyright (c) 2008-2012 Regents of the University of California
 */
/**
 * \file
 * Description not yet available.
 */
//#undef OPT_LIB
#include "fvar.h"

#if !defined(OPT_LIB)

/**
 * Description not yet available.
 * \param
 */
const dvar_vector& dvar_matrix::operator()(int i) const
 {
     if (i<rowmin())
     {
       cerr << "matrix bound exceeded -- row index too low in "
       "dvar_matrix::operator()"
             << "value was" << i << endl;
       ad_exit(21);
     }
     if (i>rowmax())
     {
       cerr << "matrix bound exceeded -- row index too high in "
       "dvar_matrix::operator()"
             << "value was" << i << endl;
       ad_exit(22);
     }
   return m[i];
 }
#endif

#ifdef __TURBOC__
#pragma hdrstop
#include <iostream.h>
#endif

#ifdef __ZTC__
#include <iostream.hpp>
#endif

#ifdef __SUN__
#include <iostream.h>
#endif
#ifdef __NDPX__
#include <iostream.h>
#endif
void dfcholeski_decomp_positive(void);
dvar_matrix choleski_decomp_positive(const dvar_matrix& MM, double eps,
  dvariable& _fpen);

/**
 * Description not yet available.
 * \param
 */
dvar_matrix positive_definite_matrix(const dvar_matrix& MM, double eps,
  dvariable& _fpen)
{
  dvar_matrix ch_m=choleski_decomp_positive(MM,eps,_fpen);
  return ch_m*trans(ch_m);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix choleski_decomp_positive(const dvar_matrix& MM, double eps,
  dvariable& _fpen)
{
  // kludge to deal with constantness
  dmatrix M=value(MM);
  double fpen;
  if (M.colsize() != M.rowsize())
  {
    cerr << "Error in chol_decomp. Matrix not square" << endl;
    ad_exit(1);
  }
  int rowsave=M.rowmin();
  int colsave=M.colmin();
  M.rowshift(1);
  M.colshift(1);
  int n=M.rowmax();

  dmatrix L(1,n,1,n);
  //dmatrix C(1,n,1,n);
  //imatrix B(1,n,1,n);
  //B.initialize();
#ifndef SAFE_INITIALIZE
    L.initialize();
#endif

  int i,j,k;
  double tmp;
  double ptmp;
  fpen=0.0;
  ptmp=posfun(M(1,1),eps,fpen);
  L(1,1)=sqrt(ptmp);
  for (i=2;i<=n;i++)
  {
    L(i,1)=M(i,1)/L(1,1);
  }

  for (i=2;i<=n;i++)
  {
    for (j=2;j<=i-1;j++)
    {
      tmp=M(i,j);
      for (k=1;k<=j-1;k++)
      {
        tmp-=L(i,k)*L(j,k);
      }
      L(i,j)=tmp/L(j,j);
    }
    tmp=M(i,i);
    for (k=1;k<=i-1;k++)
    {
      tmp-=L(i,k)*L(i,k);
    }
    ptmp=posfun(tmp,eps,fpen);
    L(i,i)=sqrt(ptmp);
  }
  L.rowshift(rowsave);
  L.colshift(colsave);

  value(_fpen)=fpen;
  dvar_matrix vc=nograd_assign(L);

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("qs");
  fp->save_prevariable_position(_fpen);
  fp->save_double_value(eps);
  fp->save_dvar_matrix_position(vc);
  fp->save_dvar_matrix_value(MM);
  save_identifier_string("rl");
  fp->save_dvar_matrix_position(MM);
  save_identifier_string("lo");
  GRAD_STACK1->set_gradient_stack(dfcholeski_decomp_positive);

  return vc;
}

/**
 * Description not yet available.
 * \param
 */
void dfcholeski_decomp_positive(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("lo");
  dvar_matrix_position MMpos=fp->restore_dvar_matrix_position();
  verify_identifier_string("rl");
  dmatrix M=fp->restore_dvar_matrix_value(MMpos);
  dvar_matrix_position vcpos=fp->restore_dvar_matrix_position();
  double eps=fp->restore_double_value();
  prevariable_position fpenpos=fp->restore_prevariable_position();
  verify_identifier_string("qs");
  dmatrix dfL=restore_dvar_matrix_derivatives(vcpos);
  double dfpen=restore_prevariable_derivative(fpenpos);

  if (M.colsize() != M.rowsize())
  {
    cerr << "Error in chol_decomp. Matrix not square" << endl;
    ad_exit(1);
  }
  int rowsave=M.rowmin();
  int colsave=M.colmin();
  dfL.rowshift(1);
  dfL.colshift(1);
  M.rowshift(1);
  M.colshift(1);
  int n=M.rowmax();

  dmatrix L(1,n,1,n);
  dvector tmp(1,n);
  dvector ptmp(1,n);
  dmatrix tmp1(1,n,1,n);
  dmatrix dftmp1(1,n,1,n);
  dmatrix dfM(1,n,1,n);
  dvector dfptmp(1,n);
  dvector dftmp(1,n);
  tmp.initialize();
  tmp1.initialize();
  dftmp.initialize();
  dftmp1.initialize();
  dfM.initialize();
#ifndef SAFE_INITIALIZE
    L.initialize();
#endif

  double fpen = 0.0;
  int i,j,k;
  ptmp(1)=posfun(M(1,1),eps,fpen);
  L(1,1)=sqrt(ptmp(1));
  for (i=2;i<=n;i++)
  {
    L(i,1)=M(i,1)/L(1,1);
  }

  for (i=2;i<=n;i++)
  {
    for (j=2;j<=i-1;j++)
    {
      tmp1(i,j)=M(i,j);
      for (k=1;k<=j-1;k++)
      {
        tmp1(i,j)-=L(i,k)*L(j,k);
      }
      L(i,j)=tmp1(i,j)/L(j,j);
    }
    tmp(i)=M(i,i);
    for (k=1;k<=i-1;k++)
    {
      tmp(i)-=L(i,k)*L(i,k);
    }
    double pen = 0.0;
    ptmp(i)=posfun(tmp(i),eps,pen);
    L(i,i)=sqrt(ptmp(i));
  }

  dfptmp.initialize();

 //*******************************************************************8
 //*******************************************************************8
 //*******************************************************************8
  for (i=n;i>=2;i--)
  {
    //L(i,i)=sqrt(ptmp(i));
    dfptmp(i)+=dfL(i,i)/(2.0*L(i,i));
    dfL(i,i)=0.0;
    // ptmp(i)=posfun(tmp(i),eps);
    dftmp(i)=dfptmp(i)*dfposfun(tmp(i),eps);
    dftmp(i)+=dfpen*dfposfun1(tmp(i),eps);
    dfptmp(i)=0.0;

    for (k=i-1;k>=1;k--)
    {
      //tmp(i)-=L(i,k)*L(i,k);
      dfL(i,k)-=2.*dftmp(i)*L(i,k);
    }
    //tmp(i)=M(i,i);
    dfM(i,i)+=dftmp(i);
    dftmp(i)=0.0;
    for (j=i-1;j>=2;j--)
    {
      //L(i,j)=tmp1(i,j)/L(j,j);
      double linv=1./L(j,j);
      dftmp1(i,j)+=dfL(i,j)*linv;
      dfL(j,j)-=dfL(i,j)*tmp1(i,j)*linv*linv;
      dfL(i,j)=0.0;
      for (k=j-1;k>=1;k--)
      {
        //tmp1(i,j)-=L(i,k)*L(j,k);
        dfL(i,k)-=dftmp1(i,j)*L(j,k);
        dfL(j,k)-=dftmp1(i,j)*L(i,k);
      }
      //tmp1(i,j)=M(i,j);
      dfM(i,j)+=dftmp1(i,j);
      dftmp1(i,j)=0.0;
    }
  }
  double linv=1./L(1,1);
  for (i=n;i>=2;i--)
  {
    //L(i,1)=M(i,1)/L(1,1);
    dfM(i,1)+=dfL(i,1)*linv;
    dfL(1,1)-=dfL(i,1)*M(i,1)*linv*linv;
    dfL(i,1)=0.0;
  }
  //L(1,1)=sqrt(ptmp(1));
  dfptmp(1)+=dfL(1,1)/(2.*L(1,1));
  dfL(1,1)=0.0;
  //ptmp(1)=posfun(M(1,1),eps,fpen);
  dfM(1,1)+=dfptmp(1)*dfposfun(M(1,1),eps);
  dfM(1,1)+=dfpen*dfposfun1(M(1,1),eps);;
  dfptmp(1)=0.0;


 //*******************************************************************8
 //*******************************************************************8
 //*******************************************************************8
  dfM.rowshift(rowsave);
  dfM.colshift(colsave);

  dfM.save_dmatrix_derivatives(MMpos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector diagonal(const dvar_matrix& m)
{
  if (m.indexmin() != m.colmin() || m.indexmax() != m.colmax())
  {
    cerr << "Error matrix not square in function diagonal" << endl;
    ad_exit(21);
  }
  int mmin=m.indexmin();
  int mmax=m.indexmax();
  dvar_vector tmp(mmin,mmax);
  for (int i=mmin;i<=mmax;i++)
    tmp(i)=m(i,i);
  return tmp;
}

/**
Returns negative elements of varmat.

\param varmat varaible matrix
*/
dvar_matrix operator-(const dvar_matrix& varmat)
{
  return -1.0 * varmat;
}

void dfmattrans(void);

/**
 * Description not yet available.
 * \param
 */
dvar_matrix trans(const dvar_matrix& m1)
{
  int rmin=m1.indexmin();
  int rmax=m1.indexmax();
  int cmin=m1.colmin();
  int cmax=m1.colmax();
  dvar_matrix t1(cmin,cmax,rmin,rmax);

  for (int i=rmin; i<=rmax; i++)
  {
    for (int j=cmin; j<=cmax; j++)
    {
      t1.elem_value(j,i)=m1.elem_value(i,j);
    }
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("uu");
  fp->save_dvar_matrix_position(m1);
  fp->save_dvar_matrix_position(t1);
  save_identifier_string("vv");
  GRAD_STACK1->set_gradient_stack(dfmattrans);

  return (t1);
}

/**
 * Description not yet available.
 * \param
 */
void dfmattrans(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("vv");
  dvar_matrix_position t1pos=fp->restore_dvar_matrix_position();
  dvar_matrix_position m1pos=fp->restore_dvar_matrix_position();
  verify_identifier_string("uu");
  dmatrix dftmp=restore_dvar_matrix_derivatives(t1pos);
  dmatrix dfm1(m1pos);
  int rmin=dfm1.indexmin();
  int rmax=dfm1.indexmax();
  int cmin=dfm1.colmin();
  int cmax=dfm1.colmax();

  for (int i=rmin; i<=rmax; i++)
  {
    for (int j=cmin; j<=cmax; j++)
    {
      //t1.elem_value(j,i)=m1.elem_value(i,j);
      dfm1(i,j)=dftmp(j,i);
    }
  }
  dfm1.save_dmatrix_derivatives(m1pos);
}

/**
  The VEC operator concatenates the columns of matrix M into a column vector.
  \param matrix M
 */
dvar_vector VEC(const dvar_matrix& _m)
  {
    dvar_matrix& m= (dvar_matrix&) _m;
    int i;
    int mmin=m.indexmin();
    int mmax=m.indexmax();
    int ii=0;
    ivector io(mmin-1,mmax);
    io(mmin-1)=0;
    for (i=mmin;i<=mmax;i++)
    {
      ii+=m(i).indexmax()-m(i).indexmin()+1;
      io(i)=ii;
    }
    dvar_vector tmp(1,ii);
    for (i=mmin;i<=mmax;i++)
    {
      tmp(io(i-1)+1,io(i)).shift(m(i).indexmin())=m(i);
    }
    return tmp;
  }

/**
  The MAT operator is the inverse of the VEC operator.
It takes the elements of vector v and sequentially fills in the columns of an n by m matrix.
  \param vector v
  \param integer n, the number of rows in the resulting matrix
  \param integer m, the umber of columns in the resulting matrix
 */
dvar_matrix MAT(const dvar_vector& v, int n, int m)
  {
    dvar_matrix tmp(1,n,1,m);
    int mmin=v.indexmin();
    int mmax=v.indexmax();
    int ii=mmin;
    if ( mmax-mmin+1 != n*m)
    {
      cerr << " Vector and Matrix sizes don't match in function MAT" << endl;
      tmp.initialize();
      return tmp;
    }
    for (int i=1;i<=n;i++)
    {
      for (int j=1;j<=m;j++)
      {
        tmp(i,j)=v(ii++);
      }
    }
    return tmp;
  }
#ifdef DEBUG
  #include <cassert>
  #include <climits>
#endif
#ifdef __TURBOC__
  #pragma hdrstop
  #include <iomanip.h>
#endif

#ifdef __ZTC__
  #include <iomanip.hpp>
#endif

#define TINY 1.0e-20;
void dfinvpret(void);

// int min(int a,int b);
void df_xldet(void);

#if defined(max)
#undef max
#endif
#if defined(min)
#undef min
#endif

dvariable ln_det(const dvar_matrix& aa, int& sgn);

dvariable ln_det(const dvar_matrix& a)
{
  int sgn = 1;
  return ln_det(a, sgn);
}
/**
\n\n The implementation of this algorithm was inspired by
"Numerical Recipes in C", 2nd edition,
Press, Teukolsky, Vetterling, Flannery, chapter 2
*/
dvariable ln_det(const dvar_matrix& aa, int& sgn)
{
  int errflag=0;
  int i,j,k;
#if defined(DEBUG) && (__cplusplus >= 201103L)
  int n = [](unsigned int colsize) -> int
  {
    assert(colsize <= INT_MAX);
    return static_cast<int>(colsize);
  } (aa.colsize());
#else
  int n = static_cast<int>(aa.colsize());
#endif
  int lb=aa.colmin();
  int ub=aa.colmax();
  ivector indx(lb,ub);
  if (lb!=aa.rowmin()||ub!=aa.colmax())
  {
    cerr << "Error matrix not square in det()"<<endl;
    ad_exit(1);
  }
  int One=1;
  indx.fill_seqadd(lb,One);
  double ld;
  double big,dum,sum,temp;
  dvar_matrix_position dmp(aa,1);
  dmatrix bb=value(aa);
  dvector vv(lb,ub);
  dvector part_prod(lb,ub);

  ld=0.0;

  dvector* pbbi = &bb(lb);
  double* pvvi = vv.get_v() + lb;
  for (i=lb;i<=ub;i++)
  {
    big=0.0;
    double* pbbij = pbbi->get_v() + lb;
    for (j=lb;j<=ub;j++)
    {
      temp=fabs(*pbbij);
      if (temp > big)
      {
        big=temp;
      }
      ++pbbij;
    }
    if (big == 0.0)
    {
      cerr << "Error in matrix inverse -- matrix singular in "
      "inv(dvar_matrix)\n";
      big=1.e+10;
      errflag=1;
    }
    *pvvi = 1.0 / big;

    ++pbbi;
    ++pvvi;
  }

  dvector* pbbj = &bb(lb);
  double* pvvj = vv.get_v() + lb;
  for (j=lb;j<=ub;j++)
  {
    pbbi = &bb(lb);
    for (i=lb;i<j;i++)
    {
      sum = *(pbbi->get_v() + j);

      double* pbbik = pbbi->get_v() + lb;
      dvector* pbbk = &bb(lb);
      for (k=lb;k<i;k++)
      {
        sum = sum - *pbbik * *(pbbk->get_v() + j);

        ++pbbik;
        ++pbbk;
      }
      //a[i][j]=sum;
      *(pbbi->get_v() + j) = sum;

      ++pbbi;
    }
    int imax = j;
    big=0.0;
    pbbi = &bb(j);
    pvvi = vv.get_v() + j;
    for (i=j;i<=ub;i++)
    {
      sum = *(pbbi->get_v() + j);

      double* pbbik = pbbi->get_v() + lb;
      dvector* pbbk = &bb(lb);
      for (k=lb;k<j;k++)
      {
        sum = sum - *pbbik * *(pbbk->get_v() + j);
        ++pbbik;
        ++pbbk;
      }
      *(pbbi->get_v() + j) = sum;
      dum = *pvvi * fabs(sum);
      if ( dum >= big)
      {
        big=dum;
        imax=i;
      }
      ++pbbi;
      ++pvvi;
    }
    if (j != imax)
    {
      double* pbbimaxk = bb(imax).get_v() + lb;
      double* pbbjk = pbbj->get_v() + lb;
      for (k=lb;k<=ub;k++)
      {
        dum = *pbbimaxk;
        *pbbimaxk = *pbbjk;
        *pbbjk = dum;

        ++pbbimaxk;
        ++pbbjk;
      }
      //d = -1.*d;
      sgn=-1*sgn;
      vv.elem(imax) = *pvvj;

      //if (j<ub)
      {
        int itemp=indx.elem(imax);
        indx.elem(imax)=indx.elem(j);
        indx.elem(j)=itemp;
      }
      //cout << "indx= " <<indx<<endl;
    }

    double* pbbjj = pbbj->get_v() + j;
    if (*pbbjj == 0.0)
    {
      *pbbjj = TINY;
    }

    if (j != n)
    {
      dum = 1.0 / *pbbjj;

      pbbi = &bb(j + 1);
      for (i=j+1;i<=ub;i++)
      {
        *(pbbi->get_v() + j) *= dum;
        ++pbbi;
      }
    }
    ++pvvj;
    ++pbbj;
  }
  double bb11 = bb(1, 1);
  if (bb11 > 0)
    part_prod(1)=ld+log(bb11);
  else
  {
    part_prod(1)=ld+log(-bb11);
    sgn=-sgn;
  }

  for (j=lb+1;j<=ub;j++)
  {
    double bbjj = bb(j, j);
    if (bbjj > 0)
      part_prod(j)=part_prod(j-1)+log(bbjj);
    else
    {
      part_prod(j)=part_prod(j-1)+log(-(bbjj));
      sgn=-sgn;
    }
  }
  double ldet=part_prod(ub);
  dvariable rdet=nograd_assign(ldet);

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("PLACE7");
  fp->save_dvector_value(part_prod);
  fp->save_dvector_position(part_prod);
  fp->save_ivector_value(indx);
  fp->save_ivector_position(indx);
  save_identifier_string("PLACE3");
  fp->save_dvar_matrix_position(aa);
  fp->save_prevariable_position(rdet);
  fp->save_dmatrix_value(bb);
  save_identifier_string("PLACE2");
  fp->save_dmatrix_position(bb);
  save_identifier_string("PLACE1");
  fp->save_double_value(ld);
  save_identifier_string("PLACE0");
  GRAD_STACK1->set_gradient_stack(df_xldet);

  if (errflag) sgn=-1;
  return rdet;
}

/// Adjoint code for dvariable ln_det(const dvar_matrix& aa, int& sgn).
void df_xldet(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("PLACE0");
  /*double ld=*/fp->restore_double_value();
  verify_identifier_string("PLACE1");
  dmatrix_position bpos=fp->restore_dmatrix_position();
  verify_identifier_string("PLACE2");
  dmatrix b=fp->restore_dmatrix_value(bpos);
  //dvar_matrix_position rdet_pos=restore_prevariable_position();
  double dfdet=fp->restore_prevariable_derivative();
  dvar_matrix_position a_pos=fp->restore_dvar_matrix_position();
  verify_identifier_string("PLACE3");
  ivector_position indx_pos=fp->restore_ivector_position();
  ivector indx=restore_ivector_value(indx_pos);
  dvector_position part_prod_pos=fp->restore_dvector_position();
  dvector part_prod=fp->restore_dvector_value(part_prod_pos);
  verify_identifier_string("PLACE7");
  int lb=b.colmin();
  int ub=b.colmax();
  dmatrix dfb(lb,ub,lb,ub);

  dvector dfpart_prod(lb,ub);

  #ifndef SAFE_INITIALIZE
    dfb.initialize();
    dfpart_prod.initialize();
  #endif

  dfpart_prod(ub)=dfdet;

  double* pdfpart_prodj = dfpart_prod.get_v() + ub;
  double* pdfpart_prodj_1 = dfpart_prod.get_v() + ub - 1;
  dvector* pbj = &b(ub);
  dvector* pdfbj = &dfb(ub);
  for (int j=ub;j>=lb+1;j--)
  {
    double bjj = *(pbj->get_v() + j);
    double* pdfbjj = pdfbj->get_v() + j;
    if (bjj > 0)
    {
      // part_prod(j)=part_prod(j-1)+log(b(j,j));
      *pdfpart_prodj_1 += *pdfpart_prodj;
      *pdfbjj += *pdfpart_prodj / bjj;
    }
    else
    {
      // part_prod(j)=part_prod(j-1)+log(-b(j,j));
      *pdfpart_prodj_1 += *pdfpart_prodj;
      *pdfbjj += *pdfpart_prodj / bjj;
    }
    *pdfpart_prodj = 0.0;

    --pdfpart_prodj;
    --pdfpart_prodj_1;
    --pbj;
    --pdfbj;
  }
  //part_prod(1)=ld+log(b(lb,lb));
  dfb(lb,lb)+=dfpart_prod(lb)/b(lb,lb);
  dfpart_prod(lb) = 0.0;

  double dfsum = 0.0;
  pdfbj = &dfb(ub);
  pbj = &b(ub);
  for (int j=ub;j>=lb;j--)
  {
    double bjj = *(pbj->get_v() + j);
    double* pdfbjj = pdfbj->get_v() + j;
    dvector* pdfbi = &dfb(ub);
    int* pindxi = indx.get_v() + ub;
    dvector* pbi = &b(ub);
    for (int i=ub;i>=lb;i--)
    {
      double* pdfbij = pdfbi->get_v() + j;
      if (i<=j)
      {
        // b(i,j)=sum;
        dfsum += *pdfbij;
        *pdfbij = 0.0;
      }
      else
      {
        // b(i,j)=sum/b(j,j);
        dfsum += *pdfbij / bjj;
        *pdfbjj -= *pdfbij * *(pbi->get_v() + j) / bjj;
        *pdfbij = 0.0;
      }

      for (int k=min(i-1,j-1);k>=lb;k--)
      {
        // sum-=b(i,k)*b(k,j);
        dfb(i,k)-=dfsum*b(k,j);
        dfb(k,j)-=dfsum*b(i,k);
      }
      // sum=value(a(indx(i),j);
      save_dmatrix_derivatives(a_pos,dfsum,*pindxi,j); // like this
      dfsum = 0.0;

      --pdfbi;
      --pindxi;
      --pbi;
    }

    --pdfbj;
    --pbj;
  }
}

#undef TINY
void dfbltsolve(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector solve(const banded_lower_triangular_dvar_matrix& m,
  const dvar_vector &v)
{
  int bw=m.bandwidth();
  int imin=m.indexmin();
  int imax=m.indexmax();
  dvar_vector x(imin,imax);
  x.elem_value(imin)=v.elem_value(imin)/m.elem_value(imin,imin);
  for (int i=imin+1;i<=imax;i++)
  {
    int jmin=admax(imin,i-bw+1);
    double ssum=0.0;
    for (int j=jmin;j<=i-1;j++)
    {
      ssum+=m.elem_value(i,j)*x.elem_value(j);
    }
    x.elem_value(i)=(v.elem_value(i)-ssum)/m.elem_value(i,i);
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("rt");
  fp->save_dvar_matrix_value(m.d);
  fp->save_dvar_matrix_position(m.d);
  fp->save_dvar_vector_value(v);
  fp->save_dvar_vector_position(v);
  fp->save_dvar_vector_position(x);
  save_identifier_string("ww");
  GRAD_STACK1->set_gradient_stack(dfbltsolve);

  return x;
}

/*
dvar_vector solve(const banded_lower_triangular_dvar_matrix& m,
  const dvar_vector &v, dvariable& lndet)
{
  int bw=m.bandwidth();
  int imin=m.indexmin();
  int imax=m.indexmax();
  dvar_vector x(imin,imax);
  value(x(imin))=value(v(1))/value(m(1,1));
  for (int i=2;i<=imax;i++)
  {
    int jmin=admax(1,i-bw+1);
    double ssum=0.0;
    for (int j=jmin;j<=i-1;j++)
    {
      ssum+=value(m(i,j))*value(x(j));
    }
    value(x(i))=(value(v(i))-ssum)/value(m(i,i));
  }
  gradient_structure* gs = gradient_structure::get();
  DF_FILE* fp = gs->fp;
  save_identifier_string("rt");
  m.save_dvar_matrix_value();
  m.save_dvar_matrix_position();
  v.save_dvar_vector_value(fp);
  v.save_dvar_vector_position(fp);
  x.save_dvar_vector_position(fp);
  save_identifier_string("ww");
  gs->GRAD_STACK1->set_gradient_stack(dfbltsolve);
  return x;
}
*/

/**
 * Description not yet available.
 * \param
 */
void dfbltsolve(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("ww");
  dvar_vector_position xpos=fp->restore_dvar_vector_position();
  dvar_vector_position vpos=fp->restore_dvar_vector_position();
  dvector v=restore_dvar_vector_value(vpos);
  dvar_matrix_position mpos=fp->restore_dvar_matrix_position();
  banded_lower_triangular_dmatrix m=
    restore_banded_lower_triangular_dvar_matrix_value(mpos);
  verify_identifier_string("rt");
  dvector dfx=
    restore_dvar_vector_derivatives(xpos);

  int bw=m.bandwidth();
  int imin=m.indexmin();
  int imax=m.indexmax();

  banded_lower_triangular_dmatrix dfm(imin,imax,bw);
  dvector x(imin,imax);
  dvector dfv(imin,imax);
  dfm.initialize();
  dfv.initialize();
  x(imin)=v(1)/m(1,1);
  dvector dfsum(imin,imax);
  dfsum.initialize();
  dvector ssum(imin,imax);
  ssum.initialize();
  int i;
  for (i=2;i<=imax;i++)
  {
    int jmin=admax(1,i-bw+1);
    for (int j=jmin;j<=i-1;j++)
    {
      ssum(i)+=m(i,j)*x(j);
    }
    x(i)=(v(i)-ssum(i))/m(i,i);
  }

  for (i=imax;i>=2;i--)
  {
    int jmin=admax(1,i-bw+1);
    //x(i)=(v(i)-ssum(i))/m(i,i);
    dfv(i)+=dfx(i)/m(i,i);
    dfsum(i)-=dfx(i)/m(i,i);
    dfm(i,i)-=dfx(i)*(v(i)-ssum(i))/(m(i,i)*m(i,i));
    dfx(i)=0.0;
    for (int j=i-1;j>=jmin;j--)
    {
      //ssum(i)+=m(i,j)*x(j);
      dfm(i,j)+=dfsum(i)*x(j);
      dfx(j)+=dfsum(i)*m(i,j);
    }
  }
  //x(imin)=v(1)/m(1,1);
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  //dfm(imax,imax)=0.0;
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  //x.elem_value(imin)=v.elem_value(imin)/m.elem_value(imin,imin);
  dfv(imin)+=dfx(imin)/m(imin,imin);
  dfm(imin,imin)-=dfx(imin)*v(imin)/(m(imin,imin)*m(imin,imin));
  dfx(imin)=0.0;

  dfm.save_dmatrix_derivatives(mpos);
  dfv.save_dvector_derivatives(vpos);
}

/**
 * Description not yet available.
 * \param
 */
banded_lower_triangular_dvar_matrix::banded_lower_triangular_dvar_matrix
   (const banded_lower_triangular_dvar_matrix& S) : bw(S.bw), d(S.d)
{}

/**
 * Description not yet available.
 * \param
 */
banded_symmetric_dvar_matrix::banded_symmetric_dvar_matrix
   (const banded_symmetric_dvar_matrix& S) : bw(S.bw), d(S.d)
{}

#if !defined(OPT_LIB)
/**
 * Description not yet available.
 * \param
 */
dvar_vector banded_symmetric_dvar_matrix::operator () (int i)
{
  return d(i);
}

/**
 * Description not yet available.
 * \param
 */
prevariable banded_symmetric_dvar_matrix::operator () (int i,int j)
{
  return d(i-j,i);
}

/**
 * Description not yet available.
 * \param
 */
prevariable banded_lower_triangular_dvar_matrix::operator () (int i,int j)
{
  return d(i-j,i);
}

const prevariable banded_lower_triangular_dvar_matrix::operator()(int i, int j)
  const
{
  return d(i-j,i);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector banded_lower_triangular_dvar_matrix::operator () (int i)
{
  return d(i);
}
#endif

/**
 * Description not yet available.
 * \param
 */
void banded_symmetric_dvar_matrix::initialize(void)
{
  for (int i=rowmin();i<=rowmax();i++)
  {
    (*this)(i).initialize();
  }
}

/**
 * Description not yet available.
 * \param
 */
void banded_lower_triangular_dvar_matrix::initialize(void)
{
  for (int i=rowmin();i<=rowmax();i++)
  {
    (*this)(i).initialize();
  }
}

/**
 * Description not yet available.
 * \param
 */
banded_symmetric_dvar_matrix::banded_symmetric_dvar_matrix
  (int _min,int _max,int _bw)
{
  bw=_bw;
  ivector  lb(0,_bw-1);
  lb.fill_seqadd(_min,1);
  d.allocate(0,_bw-1,lb,_max);
}

/**
 * Description not yet available.
 * \param
 */
banded_symmetric_dmatrix value(const banded_symmetric_dvar_matrix &v)
{
  int bw=v.bandwidth();
  banded_symmetric_dmatrix w(v.indexmin(),v.indexmax(),v.bw);
  for (int i=0;i<=bw-1;i++)
  {
    w.d(i)=value(v.d(i));
  }
  return w;
}

/**
 * Description not yet available.
 * \param
 */
banded_lower_triangular_dmatrix value
  (const banded_lower_triangular_dvar_matrix &v)
{
  int bw=v.bandwidth();
  banded_lower_triangular_dmatrix w(v.indexmin(),v.indexmax(),v.bw);
  for (int i=0;i<=bw-1;i++)
  {
    w.d(i)=value(v.d(i));
  }
  return w;
}

/**
 * Description not yet available.
 * \param
 */
ostream& operator<<(const ostream& _ofs, const banded_symmetric_dvar_matrix& S1)
{
  ostream& ofs= (ostream&) _ofs;
  banded_symmetric_dvar_matrix& S= (banded_symmetric_dvar_matrix&) S1;

  int imin=S.indexmin();
  int imax=S.indexmax();
  int bw=S.bandwidth();
  int i1;
  int j1;
  for (int i=imin;i<=imax;i++)
  {
    for (int j=imin;j<=imax;j++)
    {
      if (j<i)
      {
        j1=j;
        i1=i;
      }
      else
      {
        j1=i;
        i1=j;
      }
      if ( (i1-j1) < bw)
        ofs << S(i1,j1) << " ";
      else
        ofs << 0.0 << " ";
    }
    if (i<imax) ofs << endl;
  }
  return (ostream&)ofs;
}

/**
 * Description not yet available.
 * \param
 */
banded_lower_triangular_dvar_matrix::banded_lower_triangular_dvar_matrix
  (int _min,int _max,int _bw)
{
  bw=_bw;
  ivector  lb(0,_bw-1);
  lb.fill_seqadd(_min,1);
  d.allocate(0,_bw-1,lb,_max);
}

/**
 * Description not yet available.
 * \param
 */
ostream& operator<<(const ostream& _ofs,
  const banded_lower_triangular_dvar_matrix& S1)
{
  ostream& ofs= (ostream&) _ofs;
  banded_lower_triangular_dvar_matrix& S =
    (banded_lower_triangular_dvar_matrix&)S1;
  int imin=S.indexmin();
  int imax=S.indexmax();
  int bw=S.bandwidth();
  for (int i=imin;i<=imax;i++)
  {
    for (int j=imin;j<=imax;j++)
    {
      if (j<=i)
      {
        if ( (i-j) < bw)
          ofs << S(i,j) << " ";
        else
          ofs << 0.0 << " ";
      }
      else
      {
        ofs << 0.0 << " ";
      }
    }
    if (i<imax) ofs << endl;
  }
  return (ostream&)ofs;
}




#ifdef __TURBOC__
#pragma hdrstop
#include <iostream.h>
#endif

#ifdef __ZTC__
#include <iostream.hpp>
#endif

#ifdef __SUN__
#include <iostream.h>
#endif
#ifdef __NDPX__
#include <iostream.h>
#endif
void dfcholeski_decomp(void);
void dfcholeski_decomp_banded(void);

dvariable ln_det_choleski(
  const banded_symmetric_dvar_matrix& MM,
  int& ierr)
{
  banded_lower_triangular_dvar_matrix tmp=choleski_decomp(MM, ierr);
  dvariable ld=0.0;
  if (ierr==1)
  {
    return ld;
  }

  int mmin=tmp.indexmin();
  int mmax=tmp.indexmax();
  for (int i=mmin;i<=mmax;i++)
  {
    ld+=log(tmp(i,i));
  }
  return 2.0*ld;
}
banded_lower_triangular_dvar_matrix choleski_decomp(
  const banded_symmetric_dvar_matrix& MM,
  int& ierr)
{
  // kludge to deal with constantness
  ierr = 0;
  banded_symmetric_dvar_matrix& M = (banded_symmetric_dvar_matrix&) MM;
  int n=M.indexmax();

  int bw=M.bandwidth();
  banded_lower_triangular_dvar_matrix L(1,n,bw);
#ifndef SAFE_INITIALIZE
    L.initialize();
#endif

  int i,j,k;
  double tmp;
    if (M(1,1)<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
       " value was " << M(1,1) << " for index  1"   <<endl;
      ierr=1;
      M(1,1)=1.0;
    }
  L.elem_value(1,1)=sqrt(value(M(1,1)));
  for (i=2;i<=bw;i++)
  {
    L.elem_value(i,1)=value(M(i,1))/L.elem_value(1,1);
  }

  for (i=2;i<=n;i++)
  {
    int jmin=admax(2,i-bw+1);
    for (j=jmin;j<=i-1;j++)
    {
      tmp=value(M(i,j));
      int kmin=max(1,j-bw+1,i-bw+1);
      for (k=kmin;k<=j-1;k++)
      {
        tmp-=L.elem_value(i,k)*L.elem_value(j,k);
      }
      L.elem_value(i,j)=tmp/L.elem_value(j,j);
    }
    tmp=value(M(i,i));
    int kmin=admax(i-bw+1,1);
    //double vmax=fabs(L.elem_value(i,kmin));
    //for (k=kmin;k<=i-1;k++)
    //{
     // if (fabs(L.elem_value(i,k))>vmax) vmax=fabs(L.elem_value(i,k));
    //}
    //tmp/=square(vmax);
    for (k=kmin;k<=i-1;k++)
    {
      tmp-=L.elem_value(i,k)*L.elem_value(i,k);
      //tmp-=square(L.elem_value(i,k)/vmax);
    }
    if (tmp<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
       " value was " << tmp << " for index " << i    <<endl;
      ierr=1;

#ifdef DIAG
      int print_switch=0;
      if (print_switch)
      {
        dmatrix CMM=dmatrix(value(MM));
        ofstream ofs("hh");
        {
          ofs << setprecision(3) << setscientific() << setw(11)
              << CMM << endl<< endl;
        }
        dvector ev(CMM.indexmin(),CMM.indexmax());
        dmatrix evec=eigenvectors(CMM,ev);
        ofs << setprecision(3) << setscientific() << setw(11)
              << ev << endl<< endl;
        ofs << setprecision(3) << setscientific() << setw(11)
              << evec << endl<< endl;
        uostream uos("uos");
        uos << CMM.indexmax()-CMM.indexmin()+1;
        uos << CMM;
      }
#endif
      /*
      dmatrix N(1,4,1,4);

      for (int i=1;i<=4;i++)
      {
        N(i,i)=value(M(i,i));
        for (int j=1;j<i;j++)
        {
          N(i,j)=value(M(i,j));
          N(j,i)=value(M(i,j));
        }
      }
      cout << N << endl;
      cout << eigenvalues(N) << endl;
      cout << choleski_decomp(N) << endl;
      */

      tmp=1.0;
    }
    //L.elem_value(i,i)=vmax*sqrt(tmp);
    L.elem_value(i,i)=sqrt(tmp);
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  //banded_lower_triangular_dvar_matrix vc=nograd_assign(L);
  save_identifier_string("rs");
  fp->save_dvar_matrix_position(L.d);
  save_identifier_string("rt");
  fp->save_dvar_matrix_value(MM.d);
  save_identifier_string("rl");
  fp->save_dvar_matrix_position(MM.d);
  save_identifier_string("ro");
  GRAD_STACK1->set_gradient_stack(dfcholeski_decomp_banded);

  return L;
}

/**
 * Description not yet available.
 * \param
 */
void dfcholeski_decomp_banded(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("ro");
  dvar_matrix_position MMpos=fp->restore_dvar_matrix_position();
  verify_identifier_string("rl");
  banded_symmetric_dmatrix M=
    restore_banded_symmetric_dvar_matrix_value(MMpos);
  verify_identifier_string("rt");
  dvar_matrix_position vcpos=fp->restore_dvar_matrix_position();
  verify_identifier_string("rs");
  banded_lower_triangular_dmatrix dfL=
    restore_banded_lower_triangular_dvar_matrix_derivatives(vcpos);

  int n=M.indexmax();
  int bw=M.bandwidth();

  banded_lower_triangular_dmatrix L(1,n,bw);
  banded_lower_triangular_dmatrix tmp1(1,n,bw);
  banded_lower_triangular_dmatrix dftmp1(1,n,bw);
  banded_symmetric_dmatrix dfM(1,n,bw);
  dvector tmp(1,n);
  dvector dftmp(1,n);
  tmp.initialize();
  tmp1.initialize();
  dftmp.initialize();
  dftmp1.initialize();
  dfM.initialize();
#ifndef SAFE_INITIALIZE
    L.initialize();
#endif

  int i,j,k;
  if (M(1,1)<=0)
  {
    cerr << "Error matrix not positive definite in choleski_decomp"
      <<endl;
    M(1,1)=1.0;
    //ad_exit(1);
  }
  L(1,1)=sqrt(M(1,1));
  for (i=2;i<=bw;i++)
  {
    L(i,1)=M(i,1)/L(1,1);
  }

  for (i=2;i<=n;i++)
  {
    int jmin=admax(2,i-bw+1);
    for (j=jmin;j<=i-1;j++)
    {
      tmp1(i,j)=M(i,j);
      int kmin=max(1,j-bw+1,i-bw+1);
      for (k=kmin;k<=j-1;k++)
      {
        tmp1(i,j)-=L(i,k)*L(j,k);
      }
      L(i,j)=tmp1(i,j)/L(j,j);
    }
    tmp(i)=M(i,i);
    int kmin=admax(i-bw+1,1);
    //double vmax=fabs(L(i,kmin));
    //for (k=kmin;k<=i-1;k++)
   // {
     // if (fabs(L(i,k))>vmax) vmax=fabs(L(i,k));
   // }
    //tmp(i)/=square(vmax);
    for (k=kmin;k<=i-1;k++)
    {
      tmp(i)-=L(i,k)*L(i,k);
      //tmp(i)-=square(L(i,k)/vmax);
    }
    if (tmp(i)<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
        <<endl;
      tmp(i)=1.0;
      //ad_exit(1);
    }
    //L(i,i)=vmax*sqrt(tmp(i));
    L(i,i)=sqrt(tmp(i));
  }
 //*******************************************************************8
 //*******************************************************************8
 //*******************************************************************8
  for (i=n;i>=2;i--)
  {
    //L(i,i)=sqrt(tmp(i));
    dftmp(i)+=dfL(i,i)/(2.0*L(i,i));
    dfL(i,i)=0.0;
    int kmin=admax(i-bw+1,1);
    for (k=i-1;k>=kmin;k--)
    {
      //tmp(i)-=L(i,k)*L(i,k);
      dfL(i,k)-=2.*dftmp(i)*L(i,k);
    }
    //tmp(i)=M(i,i);
    dfM(i,i)+=dftmp(i);
    dftmp(i)=0.0;
    int jmin=admax(2,i-bw+1);
    for (j=i-1;j>=jmin;j--)
    {
      //L(i,j)=tmp1(i,j)/L(j,j);
      double linv=1./L(j,j);
      dftmp1(i,j)+=dfL(i,j)*linv;
      dfL(j,j)-=dfL(i,j)*tmp1(i,j)*linv*linv;
      dfL(i,j)=0.0;
      kmin=max(1,j-bw+1,i-bw+1);
      for (k=j-1;k>=kmin;k--)
      {
        //tmp(i,j)-=L(i,k)*L(j,k);
        dfL(i,k)-=dftmp1(i,j)*L(j,k);
        dfL(j,k)-=dftmp1(i,j)*L(i,k);
      }
      //tmp(i,j)=M(i,j);
      dfM(i,j)+=dftmp1(i,j);
      dftmp1(i,j)=0.0;
    }
  }
  double linv=1./L(1,1);
  for (i=bw;i>=2;i--)
  {
    //L(i,1)=M(i,1)/L(1,1);
    dfM(i,1)+=dfL(i,1)*linv;
    dfL(1,1)-=dfL(i,1)*M(i,1)*linv*linv;
    dfL(i,1)=0.0;
  }
  //L(1,1)=sqrt(M(1,1));
  dfM(1,1)+=dfL(1,1)/(2.*L(1,1));


 //*******************************************************************8
 //*******************************************************************8
 //*******************************************************************8

  dfM.save_dmatrix_derivatives(MMpos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix::dvar_matrix(const banded_symmetric_dvar_matrix& S1)
{
  banded_symmetric_dvar_matrix& S= (banded_symmetric_dvar_matrix&) S1;
  int imin=S.indexmin();
  int imax=S.indexmax();
  int bw=S.bandwidth();
  allocate(imin,imax,imin,imax);
  int i1;
  int j1;
  initialize();
  for (int i=imin;i<=imax;i++)
  {
    for (int j=imin;j<=imax;j++)
    {
      if (j<=i)
      {
        j1=j;
        i1=i;
      }
      else
      {
        j1=i;
        i1=j;
      }
      if ( (i1-j1) < bw)
        (*this)(i,j)=S(i1,j1);
    }
  }
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix::dvar_matrix(const banded_lower_triangular_dvar_matrix& S1)
{
  banded_lower_triangular_dvar_matrix& S=
    (banded_lower_triangular_dvar_matrix&) S1;
  int imin=S.indexmin();
  int imax=S.indexmax();
  int bw=S.bandwidth();
  allocate(imin,imax,imin,imax);
  initialize();
  for (int i=imin;i<=imax;i++)
  {
    for (int j=imin;j<=imax;j++)
    {
      if (j<=i)
      {
        if ( (i-j) < bw)
          (*this)(i,j)=S(i,j);
      }
    }
  }
}

/**
 * Description not yet available.
 * \param
 */
int max(int i,int j,int k)
{
  if (i>j)
    if ( i>k)
      return i;
    else
      return k;
  else
    if ( j>k)
      return j;
    else
      return k;
}

/**
 * Description not yet available.
 * \param
 */
dmatrix restore_lower_triangular_dvar_matrix_value(
  const dvar_matrix_position& mpos)
{
  DF_FILE* fp = gradient_structure::fp;

  // restores the size, address, and value information for a dvar_matrix
  banded_lower_triangular_dmatrix out((const dvar_matrix_position&)mpos);
  //int ierr;
  int min=out.rowmin();
  int max=out.rowmax();
  for (int i=max;i>=min;i--)
  {
    dvar_vector_position vpos=fp->restore_dvar_vector_position();
    out(i)=restore_dvar_vector_value(vpos);
  }
  return out;
}

/**
 * Description not yet available.
 * \param
 */
void check_choleski_decomp(const banded_symmetric_dvar_matrix& MM,
  const int& _ierr)
{
  int& ierr=(int&)(_ierr);
  // kludge to deal with constantness
  ierr =0;
  banded_symmetric_dvar_matrix& M = (banded_symmetric_dvar_matrix&) MM;
  int n=M.indexmax();

  int bw=M.bandwidth();
  banded_lower_triangular_dvar_matrix L(1,n,bw);
#ifndef SAFE_INITIALIZE
    L.initialize();
#endif

  int i,j,k;
  double tmp;
    if (M(1,1)<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
       " value was " << M(1,1) << " for index  1"   <<endl;
      ierr=1;
      return;
      //M(1,1)=1.0;
    }
  L.elem_value(1,1)=sqrt(value(M(1,1)));
  for (i=2;i<=bw;i++)
  {
    L.elem_value(i,1)=value(M(i,1))/L.elem_value(1,1);
  }

  for (i=2;i<=n;i++)
  {
    int jmin=admax(2,i-bw+1);
    for (j=jmin;j<=i-1;j++)
    {
      tmp=value(M(i,j));
      int kmin=max(1,j-bw+1,i-bw+1);
      for (k=kmin;k<=j-1;k++)
      {
        tmp-=L.elem_value(i,k)*L.elem_value(j,k);
      }
      L.elem_value(i,j)=tmp/L.elem_value(j,j);
    }
    tmp=value(M(i,i));
    int kmin=admax(i-bw+1,1);
    for (k=kmin;k<=i-1;k++)
    {
      tmp-=L.elem_value(i,k)*L.elem_value(i,k);
    }
    if (tmp<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
       " value was " << tmp << " for index " << i    <<endl;
      ierr=1;
      return;
      //tmp=1.0;
    }
    L.elem_value(i,i)=sqrt(tmp);
  }
}

/**
 * Description not yet available.
 * \param
 */
dvariable norm(const banded_symmetric_dvar_matrix& B)
{
  return sqrt(norm2(B));
}

/**
 * Description not yet available.
 * \param
 */
dvariable norm2(const banded_symmetric_dvar_matrix& B)
{
  dvariable nm=0.0;
  for (int i=1;i<=B.bw-1;i++)
  {
    nm+=norm2(B.d(i));
  }
  nm*=2;
  nm+=norm2(B.d(0));
  return nm;
}
dvariable sumsq(const banded_symmetric_dvar_matrix& B) {return(norm2(B));}

#ifdef __TURBOC__
#pragma hdrstop
#include <iostream.h>
#endif

#ifdef __ZTC__
#include <iostream.hpp>
#endif

#ifdef __SUN__
#include <iostream.h>
#endif
#ifdef __NDPX__
#include <iostream.h>
#endif
void dfcholeski_decomp(void);

/**
 * Description not yet available.
 * \param
 */
dvar_matrix choleski_decomp(const dvar_matrix& MM)
{
  // kludge to deal with constantness
  if (MM.colsize() != MM.rowsize())
  {
    cerr << "Error in chol_decomp. Matrix not square" << endl;
    ad_exit(1);
  }
  if (MM.colsize()==1)
  {
    int mmin=MM.indexmin();
    int mmax=MM.indexmax();
    if (MM(mmin,mmin)<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
        <<endl;
      ad_exit(1);
    }
    dvar_matrix  vc(mmin,mmax,mmin,mmax);
    vc(mmin,mmin)=sqrt(MM(mmin,mmin));
    return vc;
  }
  dmatrix M=value(MM);
  int rowsave=M.rowmin();
  int colsave=M.colmin();
  M.rowshift(1);
  M.colshift(1);
  int n=M.rowmax();

  dmatrix L(1,n,1,n);
  //dmatrix C(1,n,1,n);
  //imatrix B(1,n,1,n);
  //B.initialize();
#ifndef SAFE_INITIALIZE
    L.initialize();
#endif

  int i,j,k;
  double tmp;
    if (M(1,1)<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
        <<endl;
      ad_exit(1);
    }
  L(1,1)=sqrt(M(1,1));
  for (i=2;i<=n;i++)
  {
    /*
    if (!B(1,1))
    {
      C(1,1)=L(1,1);
      B(1,1)=1;
    }
    */
    L(i,1)=M(i,1)/L(1,1);
  }

  for (i=2;i<=n;i++)
  {
    for (j=2;j<=i-1;j++)
    {
      tmp=M(i,j);
      for (k=1;k<=j-1;k++)
      {
	/*
	if (!B(i,k))
	{
	  C(i,k)=L(i,k);
	  B(i,k)=1;
        }
	if (!B(j,k))
	{
	  C(j,k)=L(j,k);
	  B(j,k)=1;
        }
	*/
        tmp-=L(i,k)*L(j,k);
      }
      /*
      if (!B(j,j))
      {
        C(j,j)=L(j,j);
        B(j,j)=1;
      }
      */
      L(i,j)=tmp/L(j,j);
    }
    tmp=M(i,i);
    for (k=1;k<=i-1;k++)
    {
      /*
      if (!B(i,k))
      {
        C(i,k)=L(i,k);
        B(i,k)=1;
      }
      */
      tmp-=L(i,k)*L(i,k);
    }
    if (tmp<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
        <<endl;
      ad_exit(1);
    }
    L(i,i)=sqrt(tmp);
  }
  //C(n,n)=L(n,n);
  //B(n,n)=1;
  L.rowshift(rowsave);
  L.colshift(colsave);
  //cout << norm2(C-L) << endl;
  //cout << B << endl;
  //cout << L << endl;

  dvar_matrix vc=nograd_assign(L);

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("rs");
  fp->save_dvar_matrix_position(vc);
  save_identifier_string("rt");
  fp->save_dvar_matrix_value(MM);
  save_identifier_string("rl");
  fp->save_dvar_matrix_position(MM);
  save_identifier_string("ro");
  GRAD_STACK1->set_gradient_stack(dfcholeski_decomp);

  return vc;
}

/**
 * Description not yet available.
 * \param
 */
void dfcholeski_decomp(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("ro");
  dvar_matrix_position MMpos=fp->restore_dvar_matrix_position();
  verify_identifier_string("rl");
  dmatrix M=fp->restore_dvar_matrix_value(MMpos);
  verify_identifier_string("rt");
  dvar_matrix_position vcpos=fp->restore_dvar_matrix_position();
  verify_identifier_string("rs");
  dmatrix dfL=restore_dvar_matrix_derivatives(vcpos);

  if (M.colsize() != M.rowsize())
  {
    cerr << "Error in chol_decomp. Matrix not square" << endl;
    ad_exit(1);
  }
  int rowsave=M.rowmin();
  int colsave=M.colmin();
  dfL.rowshift(1);
  dfL.colshift(1);
  M.rowshift(1);
  M.colshift(1);
  int n=M.rowmax();

  dmatrix L(1,n,1,n);
  dvector tmp(1,n);
  dmatrix tmp1(1,n,1,n);
  dmatrix dftmp1(1,n,1,n);
  dmatrix dfM(1,n,1,n);
  dvector dftmp(1,n);
  tmp.initialize();
  tmp1.initialize();
  dftmp.initialize();
  dftmp1.initialize();
  dfM.initialize();
#ifndef SAFE_INITIALIZE
    L.initialize();
#endif

  int i,j,k;
  if (M(1,1)<=0)
  {
    cerr << "Error matrix not positive definite in choleski_decomp"
      <<endl;
    ad_exit(1);
  }
  L(1,1)=sqrt(M(1,1));
  for (i=2;i<=n;i++)
  {
    L(i,1)=M(i,1)/L(1,1);
  }

  for (i=2;i<=n;i++)
  {
    for (j=2;j<=i-1;j++)
    {
      tmp1(i,j)=M(i,j);
      for (k=1;k<=j-1;k++)
      {
        tmp1(i,j)-=L(i,k)*L(j,k);
      }
      L(i,j)=tmp1(i,j)/L(j,j);
    }
    tmp(i)=M(i,i);
    for (k=1;k<=i-1;k++)
    {
      tmp(i)-=L(i,k)*L(i,k);
    }
    if (tmp(i)<=0)
    {
      cerr << "Error matrix not positive definite in choleski_decomp"
        <<endl;
      ad_exit(1);
    }
    L(i,i)=sqrt(tmp(i));
  }
 //*******************************************************************8
 //*******************************************************************8
 //*******************************************************************8
  for (i=n;i>=2;i--)
  {
    //L(i,i)=sqrt(tmp(i));
    dftmp(i)+=dfL(i,i)/(2.0*L(i,i));
    dfL(i,i)=0.0;
    for (k=i-1;k>=1;k--)
    {
      //tmp(i)-=L(i,k)*L(i,k);
      dfL(i,k)-=2.*dftmp(i)*L(i,k);
    }
    //tmp(i)=M(i,i);
    dfM(i,i)+=dftmp(i);
    dftmp(i)=0.0;
    for (j=i-1;j>=2;j--)
    {
      //L(i,j)=tmp1(i,j)/L(j,j);
      double linv=1./L(j,j);
      dftmp1(i,j)+=dfL(i,j)*linv;
      dfL(j,j)-=dfL(i,j)*tmp1(i,j)*linv*linv;
      dfL(i,j)=0.0;
      for (k=j-1;k>=1;k--)
      {
        //tmp(i,j)-=L(i,k)*L(j,k);
        dfL(i,k)-=dftmp1(i,j)*L(j,k);
        dfL(j,k)-=dftmp1(i,j)*L(i,k);
      }
      //tmp(i,j)=M(i,j);
      dfM(i,j)+=dftmp1(i,j);
      dftmp1(i,j)=0.0;
    }
  }
  double linv=1./L(1,1);
  for (i=n;i>=2;i--)
  {
    //L(i,1)=M(i,1)/L(1,1);
    dfM(i,1)+=dfL(i,1)*linv;
    dfL(1,1)-=dfL(i,1)*M(i,1)*linv*linv;
    dfL(i,1)=0.0;
  }
  //L(1,1)=sqrt(M(1,1));
  dfM(1,1)+=dfL(1,1)/(2.*L(1,1));


 //*******************************************************************8
 //*******************************************************************8
 //*******************************************************************8
  dfM.rowshift(rowsave);
  dfM.colshift(colsave);

  dfM.save_dmatrix_derivatives(MMpos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator*(const prevariable& x, const dmatrix& m)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int rmin=m.rowmin();
  int rmax=m.rowmax();

  ivector cmin(rmin,rmax);
  ivector cmax(rmin,rmax);

  const dvector* pmi = &m(rmin);
  int* pcmini = cmin.get_v() + rmin;
  int* pcmaxi = cmax.get_v() + rmin;
  for (int i=rmin;i<=rmax;++i)
  {
    *pcmini = pmi->indexmin();
    *pcmaxi = pmi->indexmax();

    ++pcmini;
    ++pcmaxi;
    ++pmi;
  }

  dvar_matrix tmp(rmin,rmax,cmin,cmax);

  pmi = &m(rmin);
  dvar_vector *ptmpi = &tmp(rmin);
  for (int i=rmin;i<=rmax;++i)
  {
    *ptmpi = x * *pmi;

    ++pmi;
    ++ptmpi;
  }

  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator*(const dvar_matrix& m, const double x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int rmin=m.rowmin();
  int rmax=m.rowmax();

  ivector cmin(rmin,rmax);
  ivector cmax(rmin,rmax);

  const dvar_vector* pmi = &m(rmin);
  int* pcmini = cmin.get_v() + rmin;
  int* pcmaxi = cmax.get_v() + rmin;
  for (int i=rmin;i<=rmax;++i)
  {
    *pcmini = pmi->indexmin();
    *pcmaxi = pmi->indexmax();

    ++pcmini;
    ++pcmaxi;
    ++pmi;
  }
  dvar_matrix tmp(rmin,rmax,cmin,cmax);

  pmi = &m(rmin);
  dvar_vector *ptmpi = &tmp(rmin);
  for (int i=rmin;i<=rmax;++i)
  {
    *ptmpi = x * *pmi;

    ++pmi;
    ++ptmpi;
  }

  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator*(const double x, const dvar_matrix& m)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();
  int rmin=m.rowmin();
  int rmax=m.rowmax();

  ivector cmin(rmin,rmax);
  ivector cmax(rmin,rmax);

  const dvar_vector* pmi = &m(rmin);
  int* pcmini = cmin.get_v() + rmin;
  int* pcmaxi = cmax.get_v() + rmin;
  for (int i=rmin;i<=rmax;++i)
  {
    *pcmini = pmi->indexmin();
    *pcmaxi = pmi->indexmax();

    ++pcmini;
    ++pcmaxi;
    ++pmi;
  }

  dvar_matrix tmp(rmin,rmax,cmin,cmax);

  pmi = &m(rmin);
  dvar_vector *ptmpi = &tmp(rmin);
  for (int i=rmin;i<=rmax;++i)
  {
    *ptmpi = x * *pmi;

    ++pmi;
    ++ptmpi;
  }
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}

/**
Construct AD variable matrix with dimensions nrl to nrh by ncl to nch.

\param nrl lower row index
\param nrh higher row index
\param ncl lower column index
\param nch higher column index
*/
dvar_matrix::dvar_matrix(
  const ad_integer& nrl, const ad_integer& nrh,
  const index_type& ncl, const index_type& nch)
{
  allocate(nrl,nrh,ncl,nch);
#ifndef OPT_LIB
  initialize();
#endif
}
/**
Allocates AD variable matrix with dimensions nrl to nrh by ncl to nch.

\param nrl lower row index
\param nrh higher row index
\param ncl lower column index
\param nch higher column index
*/
void dvar_matrix::allocate(
  const ad_integer& nrl, const ad_integer& nrh,
  const index_type& ncl, const index_type& nch)
{
  if (nrl>nrh)
  {
    allocate();
  }
  else
  {
    //if (nrl !=ncl.indexmin() || nrh !=ncl.indexmax() ||
    //  nrl !=nch.indexmin() || nrh !=nch.indexmax())
    if ((ncl.isinteger() && (nrl !=ncl.indexmin() || nrh !=ncl.indexmax())) ||
       (nch.isinteger() && (nrl !=nch.indexmin() || nrh !=nch.indexmax())))
    {
      cerr << "Incompatible array bounds in dvar_matrix(int nrl,int nrh,"
              "const ivector& ncl, const ivector& nch)" << endl;
      ad_exit(1);
    }
    index_min=int(nrl);
    index_max=int(nrh);
    if ((m = new dvar_vector[rowsize()]) == 0)
    {
      cerr << " Error allocating memory in dmatrix contructor" << endl;
      ad_exit(21);
    }
    if ((shape = new mat_shapex(m)) == 0)
    {
      cerr << " Error allocating memory in dvar_matrix contructor" << endl;
      ad_exit(21);
    }
    m -= int(nrl);
    for (int i=nrl; i<=nrh; i++)
    {
      m[i].allocate(ncl[i],nch[i]);
    }
  }
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


#include <stdio.h>
#ifndef __SUN__
#endif
#include <math.h>

/**
 * Description not yet available.
 * \param
 */
double dvar_matrix::fill_seqadd(const double x, const double d)
{
  double x1=x;
  double d1=d;
  for (int i=rowmin();i<=rowmax();i++)
  {
    elem(i).fill_seqadd(x1,d1);
    x1+=elem(i).size()*d1;
  }
  return x1;
}
#include "admb_messages.h"

/**
 * Description not yet available.
 * \param
 */
dvariable colsum(const dvar_matrix& m, int col)
{
  if (col < m.rowmin() || col > m.rowmax())
  {
    ADMB_ARRAY_BOUNDS_ERROR("Row out of bounds",
    "dvariable colsum(const dvar_matrix& m, int col)",
    m.rowmin(), m.rowmax(), col);
  }
  dvariable isum=0.0;
  int mmin=m.rowmin();
  int mmax=m.rowmax();
  for (int i=mmin;i<=mmax;i++)
  {
    isum+=m(i,col);
  }
  return isum;
}

void dmcv_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const dvar_matrix& m, const dvector& x)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;

  gs->RETURN_ARRAYS_INCREMENT();

  int imin = m.rowmin();
  int imax = m.rowmax();
  int jmin = x.indexmin();
  int jmax = x.indexmax();

#ifndef OPT_LIB
  if (x.indexmin() != m.colmin() || x.indexmax() != m.colmax())
  {
    cerr << " Incompatible array bounds in "
     "dvar_vector operator * (const dvar_matrix& m, const dvar_vector& x)\n";
    ad_exit(21);
  }
#endif

  kkludge_object kludge;
  dvar_vector tmp(imin, imax, kludge);

  double_and_int* ptmpi = tmp.va + imin;
  const dvar_vector* pmi = &m(imin);
  for (int i = imin; i <= imax; ++i)
  {
    double sum = 0.0;
    const double_and_int* pmij = pmi->va + jmin;
    double* pxj = x.get_v() + jmin;
    for (int j = jmin; j <= jmax; ++j)
    {
      //sum+=m[i][j]*x[j];
      sum += pmij->x  * *pxj;
      ++pxj;
      ++pmij;
    }
    ptmpi->x = sum;

    ++pmi;
    ++ptmpi;
  }
  save_identifier_string("PL4");
  fp->save_dvector_value(x);
  fp->save_dvector_position(x);
  fp->save_dvar_matrix_position(m);
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("PLX");
  gs->GRAD_STACK1->set_gradient_stack(dmcv_prod);
  gs->RETURN_ARRAYS_DECREMENT();

  return tmp;
 }

/**
 * Description not yet available.
 * \param
 */
void dmcv_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("PLX");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvar_matrix_position m_pos=fp->restore_dvar_matrix_position();
  dvar_vector_position x_pos=fp->restore_dvar_vector_position();
  dvector x=restore_dvar_vector_value(x_pos);
  verify_identifier_string("PL4");
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);

  dmatrix dfm(m_pos);
  dfm.initialize();

  int mmin = dfm.rowmin();
  int mmax = dfm.rowmax();
  int jmin = x.indexmin();
  int jmax = x.indexmax();
  double* pdftmpi = dftmp.get_v() + mmax;
  dvector* pdfmi = &dfm(mmax);
  for (int i=mmax; i>=mmin; i--)
  {
     // tmp.elem_value(i)=sum;
     double dfsum = *pdftmpi;
     double* pdfmij = pdfmi->get_v() + jmax;
     double* pxj = x.get_v() + jmax;
     for (int j = jmax; j >= jmin; --j)
     {
       //sum+=(m.elem(i)).elem_value(j)*x.elem_value(j);
       *pdfmij += dfsum * *pxj;

       --pdfmij;
       --pxj;
     }
     //sum=0.0;
     dfsum = 0.0;

     --pdfmi;
     --pdftmpi;
  }
  dfm.save_dmatrix_derivatives(m_pos);
}

/**
 * Description not yet available.
 * \param
 */
void dmatrix::allocate(const dvar_matrix& dm)
{
  int nrl = dm.rowmin();
  int nrh = dm.rowmax();

  index_min = nrl;
  index_max = nrh;

  if ((m = new dvector[rowsize()]) == 0)
  {
    cerr << " Error allocating memory in dmatrix contructor\n";
    ad_exit(21);
  }
  if ((shape = new mat_shapex(m)) == 0)
  {
    cerr << " Error allocating memory in dmatrix contructor\n";
    ad_exit(21);
  }

  m -= nrl;
  dvector* pmi = m + nrl;
  const dvar_vector* pdmi = &dm(nrl);
  for (int i = nrl; i <= nrh; ++i)
  {
    pmi->allocate(*pdmi);

    ++pmi;
    ++pdmi;
  }
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


#include <stdio.h>
#ifndef __SUN__
#endif
#include <math.h>

/**
 * Description not yet available.
 * \param
 */
dvar_matrix mfexp(const dvar_matrix& m)
{
  dvar_matrix tmp;

  int min = m.indexmin();
  int max = m.indexmax();
  tmp.allocate(min, max);
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = mfexp(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix mfexp(const dvar_matrix& m, const double d)
{
  dvar_matrix tmp;

  int min = m.indexmin();
  int max = m.indexmax();
  tmp.allocate(min, max);
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = mfexp(*pmi, d);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


#include <stdio.h>
#ifndef __SUN__
#endif
#include <math.h>

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator/(const double e, const dvar_matrix& m)
{
  dvar_matrix tmp;
  int min = m.indexmin();
  int max = m.indexmax();
  tmp.allocate(min, max);

  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = e / *pmi;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator/(const prevariable& e, const dvar_matrix& m)
{
  dvar_matrix tmp;

  int min = m.indexmin();
  int max = m.indexmax();
  tmp.allocate(min, max);

  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = e / *pmi;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator/(const prevariable& e, const dmatrix& m)
{
  dvar_matrix tmp;

  int min = m.indexmin();
  int max = m.indexmax();
  tmp.allocate(min, max);

  dvar_vector* ptmpi = &tmp(min);
  const dvector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = e / *pmi;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


#include <stdio.h>
#ifndef __SUN__
#endif
#include <math.h>

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator/(const dvar_matrix& m, const double e)
{
  dvar_matrix tmp;
  int min = m.indexmin();
  int max = m.indexmax();
  if (min <= max)
  {
    tmp.allocate(min, max);
    dvar_vector* ptmp = &tmp(min);
    const dvar_vector* pm = &m(min);
    for (int i = min; i <= max; ++i)
    {
      *ptmp = *pm / e;
      ++pm;
      ++ptmp;
    }
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator/(const dvar_matrix& m, const prevariable& e)
{
  dvar_matrix tmp;
  int min = m.indexmin();
  int max = m.indexmax();
  if (min <= max)
  {
    tmp.allocate(min, max);
    dvar_vector* ptmp = &tmp(min);
    const dvar_vector* pm = &m(min);
    for (int i = min; i <= max; ++i)
    {
      *ptmp = *pm / e;
      ++pm;
      ++ptmp;
    }
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator/(const dmatrix& m, const prevariable& e)
{
  dvar_matrix tmp;
  int min = m.indexmin();
  int max = m.indexmax();
  tmp.allocate(min, max);
  if (min <= max)
  {
    dvar_vector* ptmp = &tmp(min);
    const dvector* pm = &m(min);
    for (int i = min; i <= max; ++i)
    {
      *ptmp = *pm / e;
      ++pm;
      ++ptmp;
    }
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix symmetrize(const dvar_matrix& m)
{
  if (m.rowmin() != m.colmin() || m.rowmax() != m.colmax() )
  {
    cerr << " Non square matrix passed to dmatrix symmetrize\n";
    ad_exit(1);
  }
  int rmin=m.rowmin();
  int rmax=m.rowmax();

  dvar_matrix s(rmin,rmax,rmin,rmax);


  for (int i=rmin;i<=rmax;i++)
  {
    s(i,i)=m(i,i);
    for (int j=rmin;j<i;j++)
    {
      s(i,j)=(m(i,j)+m(j,i))/2.;
      s(j,i)=s(i,j);
    }
  }

  return s;
}

/**
Return the variable mean of matrix m.
*/
dvariable mean(const dvar_matrix& m)
{
  dvariable tmp;
  const unsigned int size = size_count(m);
  if (size > 0)
  {
    tmp = sum(m) / size;
  }
  else
  {
    cerr << "Error: Unable to compute mean of dvar_matrix.\n";
    ad_exit(1);
  }
  return tmp;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


#include <stdio.h>
#ifndef __SUN__
#endif
#include <math.h>

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator/=(const double x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();
  int min = index_min;
  int max = index_max;
  dvar_vector* pv = m + min;
  for (int i = min; i <= max; ++i)
  {
    *pv /= x;
    ++pv;
  }
  gs->RETURN_ARRAYS_DECREMENT();
  return (*this);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator/=(const prevariable& x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();
  int min = index_min;
  int max = index_max;
  dvar_vector* pv = m + min;
  for (int i = min; i <= max; ++i)
  {
    *pv /= x;
    ++pv;
  }
  gs->RETURN_ARRAYS_DECREMENT();
  return (*this);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator=(const double x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();
  int min = index_min;
  int max = index_max;
  dvar_vector* pv = m + min;
  for (int i = min; i <= max; ++i)
  {
    *pv = x;
    ++pv;
  }
  gs->RETURN_ARRAYS_DECREMENT();
  return (*this);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator=(const prevariable& x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();
  int min = index_min;
  int max = index_max;
  dvar_vector* pv = m + min;
  for (int i = min; i <= max; ++i)
  {
    *pv = x;
    ++pv;
  }
  gs->RETURN_ARRAYS_DECREMENT();
  return (*this);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator*=(const double x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();
  int min = index_min;
  int max = index_max;
  dvar_vector* pv = m + min;
  for (int i = min; i <= max; ++i)
  {
    *pv *= x;
    ++pv;
  }
  gs->RETURN_ARRAYS_DECREMENT();
  return (*this);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator*=(const prevariable& x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();
  int min = index_min;
  int max = index_max;
  dvar_vector* pv = m + min;
  for (int i = min; i <= max; ++i)
  {
    *pv *= x;
    ++pv;
  }
  gs->RETURN_ARRAYS_DECREMENT();
  return (*this);
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


#include <stdio.h>
#ifndef __SUN__
#endif
#include <math.h>

// dvar_matrix mathematical functions
dvar_matrix exp(const dvar_matrix& m);
dvar_matrix log(const dvar_matrix& m);
dvar_matrix sin(const dvar_matrix& m);
dvar_matrix cos(const dvar_matrix& m);
dvar_matrix tan(const dvar_matrix& m);
dvar_matrix pow(const dvar_matrix& m, const double e);
dvar_matrix pow(const dvar_matrix& m, const prevariable& e);
dvar_matrix pow(const dmatrix& m, const prevariable& e);
dvar_matrix pow(const dvar_matrix& m, int e);
dvar_matrix elem_prod(const dvar_matrix& m, const dvar_matrix& m2);
dvar_matrix elem_prod(const dvar_matrix& m, const dmatrix& m2);
dvar_matrix elem_prod(const dmatrix& m, const dvar_matrix& m2);
dvar_matrix elem_div(const dvar_matrix& m, const dvar_matrix& m2);
dvar_matrix elem_div(const dvar_matrix& m, const dmatrix& m2);
dvar_matrix elem_div(const dmatrix& m, const dvar_matrix& m2);
// end of dvar_vector mathematical functions

/*  "template form for editor
dvar_matrix XXX(const dvar_matrix& m)
{
  ivector cmin(m.rowmin(),m.rowmax());
  ivector cmax(m.rowmin(),m.rowmax());
  for (int i=m.rowmin();i<=m.rowmax();i++)
  {
    cmin(i)=m(i).indexmin();
    cmax(i)=m(i).indexmax();
  }
  dvar_matrix tmp(m.rowmin(),m.rowmax(),cmin,cmax);
  for (i=m.rowmin();i<=m.rowmax();i++)
  {
    tmp(i)=XXX(m(i));
  }
  return tmp;
}

*/

/**
 * Description not yet available.
 * \param
 */
dvar_matrix use_shape(const dvar_matrix& m)
{
  int min = m.rowmin();
  int max = m.rowmax();
  ivector cmin(min, max);
  ivector cmax(min, max);
  int* pcmini = cmin.get_v() + min;
  int* pcmaxi = cmax.get_v() + min;
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *pcmini = pmi->indexmin();
    *pcmaxi = pmi->indexmax();

    ++pmi;
    ++pcmini;
    ++pcmaxi;
  }
  dvar_matrix tmp(min, max, cmin, cmax);
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dmatrix use_shape(const dmatrix& m)
{
  int min = m.rowmin();
  int max = m.rowmax();
  ivector cmin(min, max);
  ivector cmax(min, max);

  int* pcmini = cmin.get_v() + min;
  int* pcmaxi = cmax.get_v() + min;
  const dvector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *pcmini = pmi->indexmin();
    *pcmaxi = pmi->indexmax();

    ++pmi;
    ++pcmini;
    ++pcmaxi;
  }
  dmatrix tmp(min, max, cmin, cmax);
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix pow(const dvar_matrix& m, int e)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = pow(*pmi, e);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix pow(const dmatrix& m, const prevariable& e)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = pow(*pmi, e);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix pow(const dvar_matrix& m, const prevariable& e)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = pow(*pmi, e);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix pow(const dvar_matrix& m, const double e)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = pow(*pmi, e);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix tan(const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = tan(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix cos(const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = cos(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix sin(const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = sin(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix log(const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = log(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix sqrt(const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = sqrt(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix sqr(const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = sqr(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix exp(const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = exp(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix elem_div(const dvar_matrix& m, const dvar_matrix& m2)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  const dvar_vector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = elem_div(*pmi, *pm2i);

    ++ptmpi;
    ++pmi;
    ++pm2i;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix elem_div(const dmatrix& m,const dvar_matrix& m2)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvector* pmi = &m(min);
  const dvar_vector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = elem_div(*pmi, *pm2i);

    ++ptmpi;
    ++pmi;
    ++pm2i;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix elem_div(const dvar_matrix& m, const dmatrix& m2)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  const dvector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = elem_div(*pmi, *pm2i);

    ++ptmpi;
    ++pmi;
    ++pm2i;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix elem_prod(const dvar_matrix& m, const dvar_matrix& m2)
{
  //dvar_matrix tmp=use_shape(m);
  int min = m.rowmin();
  int max = m.rowmax();
  dvar_matrix tmp(min, max);

  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  const dvar_vector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = elem_prod(*pmi, *pm2i);

    ++ptmpi;
    ++pmi;
    ++pm2i;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix elem_prod(const dmatrix& m, const dvar_matrix& m2)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvector* pmi = &m(min);
  const dvar_vector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = elem_prod(*pmi, *pm2i);

    ++ptmpi;
    ++pmi;
    ++pm2i;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix elem_prod(const dvar_matrix& m, const dmatrix& m2)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  const dvector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = elem_prod(*pmi, *pm2i);

    ++ptmpi;
    ++pmi;
    ++pm2i;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator+(const double x, const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = x + *pmi;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator*(const prevariable& x, const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = x * *pmi;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator+(const dvar_matrix& m, const double x)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = *pmi + x;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator+(const dvariable& x, const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = x + *pmi;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator+(const dvar_matrix& m, const dvariable& x)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = *pmi + x;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator*(const dvar_matrix& m, const prevariable& x)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = *pmi * x;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator-(const dvar_matrix& m, const double x)
{
  dvar_matrix tmp=use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = *pmi - x;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator-(const double x, const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = x - *pmi;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator-(const dvar_matrix& m, const dvariable& x)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = *pmi - x;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator-(const dvariable& x, const dvar_matrix& m)
{
  dvar_matrix tmp = use_shape(m);

  int min = m.rowmin();
  int max = m.rowmax();
  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pmi = &m(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = x - *pmi;

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}
#ifdef DEBUG
  #include <cassert>
  #include <climits>
#endif

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#if defined (__WAT32__)
  #include <iostream.h>
  #include <strstrea.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

#define TINY 1.0e-20;
void dmdv_solve(void);

dvar_vector solve(const dvar_matrix& aa, const dvar_vector& z,
  prevariable& ln_unsigned_det, const prevariable& sign);
/** Solve a linear system using LU decomposition.
\param aa A dvar_matrix containing LU decomposition of input matrix. \f$a\f$.
    \param z A dvar_vector containing the RHS, \f$b\f$ of the linear equation
    \f$A\cdot X = B\f$, to be solved.
    \return A dvar_vector containing solution vector \f$X\f$.
*/
dvar_vector solve(const dvar_matrix& aa, const dvar_vector& z)
{
  dvariable ln_unsigned_det;
  dvariable sign;
  dvar_vector sol=solve(aa,z,ln_unsigned_det,sign);
  return sol;
}

/** Solve a linear system using LU decomposition.
\param aa A dvar_matrix containing LU decomposition of input matrix. \f$a\f$.
    \param z A dvar_vector containing the RHS, \f$b\f$ of the linear equation
    \f$A\cdot X = B\f$, to be solved.
    \param _ln_unsigned_deg
    \param sign
    \return A dvar_vector containing solution vector \f$X\f$.
    \n\n The implementation of this algorithm was inspired by
    "Numerical Recipes in C", 2nd edition,
    Press, Teukolsky, Vetterling, Flannery, chapter 2
*/
dvar_vector solve(const dvar_matrix& aa, const dvar_vector& z,
  prevariable& ln_unsigned_det, const prevariable& _sign)
{
  prevariable& sign=(prevariable&) _sign;

  gradient_structure* gs = gradient_structure::get();
  DF_FILE* fp = gs->fp;

  gs->RETURN_ARRAYS_INCREMENT();

#if defined(DEBUG) && (__cplusplus >= 201103L)
  int n = [](unsigned int colsize) -> int
  {
    assert(colsize <= INT_MAX);
    return static_cast<int>(colsize);
  } (aa.colsize());
#else
  int n = static_cast<int>(aa.colsize());
#endif
  int lb=aa.colmin();
  int ub=aa.colmax();
  if (lb!=aa.rowmin()||ub!=aa.colmax())
  {
    cerr << "Error matrix not square in solve()"<<endl;
    ad_exit(1);
  }
  ivector indx(lb,ub);
  int One=1;
  indx.fill_seqadd(lb,One);
  double d;
  double big,dum,sum,temp;
  dvar_matrix_position dmp(aa,0);
  dmatrix bb=value(aa);
  kkludge_object kkk;
  dvar_vector vc(lb,ub,kkk);
  dvector vv(lb,ub);

  d=1.0;
  for (int i=lb;i<=ub;i++)
  {
    big=0.0;
    double* pbbij = bb.elem(i).get_v() + lb;
    for (int j=lb;j<=ub;j++)
    {
      //temp=fabs(bb.elem(i,j));
      temp=fabs(*pbbij);
      ++pbbij;

      if (temp > big)
      {
        big=temp;
      }
    }
    if (big == 0.0)
    {
      cerr << "Error in matrix inverse -- matrix singular in "
      "solve(dvar_dmatrix)\n";
    }
    vv[i]=1.0/big;
  }

  for (int j=lb;j<=ub;j++)
  {
    for (int i=lb;i<j;i++)
    {
      sum=bb.elem(i,j);
      for (int k=lb;k<i;k++)
      {
        sum -= bb.elem(i,k)*bb.elem(k,j);
      }
      //a[i][j]=sum;
      bb.elem(i,j)=sum;
    }
    int imax = j;
    big=0.0;
    for (int i=j;i<=ub;i++)
    {
      sum=bb.elem(i,j);
      for (int k=lb;k<j;k++)
      {
        sum -= bb.elem(i,k)*bb.elem(k,j);
      }
      bb.elem(i,j)=sum;
      dum=vv[i]*fabs(sum);
      if ( dum >= big)
      {
        big=dum;
        imax=i;
      }
    }
    if (j != imax)
    {
      for (int k=lb;k<=ub;k++)
      {
        dum=bb.elem(imax,k);
        bb.elem(imax,k)=bb.elem(j,k);
        bb.elem(j,k)=dum;
      }
      d = -1.*d;
      vv[imax]=vv[j];

      //if (j<ub)
      {
        int itemp=indx.elem(imax);
        indx.elem(imax)=indx.elem(j);
        indx.elem(j)=itemp;
      }
      //cout << "indx= " <<indx<<endl;
    }

    if (bb.elem(j,j) == 0.0)
    {
      bb.elem(j,j)=TINY;
    }

    if (j != n)
    {
      dum=1.0/bb.elem(j,j);
      for (int i=j+1;i<=ub;i++)
      {
        bb.elem(i,j) = bb.elem(i,j) * dum;
      }
    }
  }

  // get the determinant
  sign=d;
  dvector part_prod(lb,ub);
  part_prod(lb)=log(fabs(bb(lb,lb)));
  if (bb(lb,lb)<0) sign=-sign;
  for (int j=lb+1;j<=ub;j++)
  {
    if (bb(j,j)<0) sign=-sign;
    part_prod(j)=part_prod(j-1)+log(fabs(bb(j,j)));
  }
  ln_unsigned_det=part_prod(ub);

  dvector x(lb,ub);
  dvector y(lb,ub);
  //int lb=rowmin;
  //int ub=rowmax;
  dmatrix& b=bb;
  ivector indxinv(lb,ub);
  for (int i=lb;i<=ub;i++)
  {
    indxinv(indx.elem(i))=i;
  }

  for (int i=lb;i<=ub;i++)
  {
    y.elem(indxinv(i))=z.elem_value(i);
  }

  for (int i=lb;i<=ub;i++)
  {
    sum=y.elem(i);
    for (int j=lb;j<=i-1;j++)
    {
      sum-=b.elem(i,j)*y.elem(j);
    }
    y.elem(i)=sum;
  }
  for (int i=ub;i>=lb;i--)
  {
    sum=y.elem(i);
    for (int j=i+1;j<=ub;j++)
    {
      sum-=b.elem(i,j)*x.elem(j);
    }
    x.elem(i)=sum/b.elem(i,i);
  }

  vc=nograd_assign(x);
  fp->save_prevariable_position(ln_unsigned_det);
  fp->save_dvector_value(part_prod);
  fp->save_dvector_position(part_prod);
  fp->save_dvector_value(y);
  fp->save_dvector_value(x);
  fp->save_dvector_position(x);
  fp->save_dvector_position(y);
  fp->save_ivector_value(indx);
  fp->save_ivector_position(indx);
  fp->save_dvar_matrix_position(aa);
  fp->save_dvar_vector_position(vc);
  fp->save_dmatrix_value(bb);
  fp->save_dmatrix_position(bb);
  fp->save_dvar_vector_position(z);
  gs->GRAD_STACK1->set_gradient_stack(dmdv_solve);
  gs->RETURN_ARRAYS_DECREMENT();
  return vc;
}

/// Adjoint code for
/// dvar_vector solve(const dvar_matrix& aa, const dvar_vector& z,
void dmdv_solve(void)
{
  gradient_structure* gs = gradient_structure::get();
  DF_FILE* fp = gs->fp;

  dvar_vector_position zpos=fp->restore_dvar_vector_position();
  dmatrix_position bpos=fp->restore_dmatrix_position();
  dmatrix b=fp->restore_dmatrix_value(bpos);
  dvar_vector_position v_pos=fp->restore_dvar_vector_position();
  dvar_matrix_position a_pos=fp->restore_dvar_matrix_position();
  ivector_position indx_pos=fp->restore_ivector_position();
  ivector indx=restore_ivector_value(indx_pos);
  dvector_position y_pos=fp->restore_dvector_position();
  dvector_position x_pos=fp->restore_dvector_position();
  dvector x=fp->restore_dvector_value(x_pos);
  dvector y=fp->restore_dvector_value(y_pos);
  dvector_position part_prod_pos=fp->restore_dvector_position();
  dvector part_prod=fp->restore_dvector_value(part_prod_pos);
  double df_ln_det=fp->restore_prevariable_derivative();
  int lb=b.colmin();
  int ub=b.colmax();
  dmatrix dfb(lb,ub,lb,ub);
  dvector dfz(lb,ub);
  dvector dfx=restore_dvar_vector_derivatives(v_pos);
  dvector dfy(lb,ub);
  dvector dfpart_prod(lb,ub);
  ivector indxinv(lb,ub);
  for (int i=lb;i<=ub;i++)
  {
    indxinv(indx.elem(i))=i;
  }

  double dfsum=0.;
  #ifndef SAFE_INITIALIZE
    dfb.initialize();
    dfy.initialize();
    dfz.initialize();
    dfpart_prod.initialize();
  #endif

  for (int i=lb;i<=ub;i++)
  {
    // x.elem(i)=sum/b.elem(i,i);
    dfsum+=dfx.elem(i)/b.elem(i,i);
    dfb.elem(i,i)-=dfx.elem(i)*x.elem(i)/b.elem(i,i);
    dfx.elem(i)=0.;
    for (int j=ub;j>=i+1;j--)
    {
      // sum -=b.elem(i,j)*x.elem(j);
      dfb.elem(i,j)-=dfsum*x.elem(j);
      dfx.elem(j)-=dfsum*b.elem(i,j);
    }
    // sum=y.elem(i);
    dfy.elem(i)+=dfsum;
    dfsum=0.;
  }

  for (int i=ub;i>=lb;i--)
  {
    // y.elem(i)=sum;
    dfsum+=dfy.elem(i);
    dfy.elem(i)=0.;
    for (int j=i-1;j>=lb;j--)
    {
      // sum-=b.elem(i,j)*y.elem(j);
      dfb.elem(i,j)-=dfsum*y.elem(j);
      dfy.elem(j)-=dfsum*b.elem(i,j);
    }
    //sum=y.elem(i);
    dfy.elem(i)=dfsum;
    dfsum=0.;
  }

  for (int i=ub;i>=lb;i--)
  {
    //y.elem(indxinv(i))=z.elem_value(i);
    dfz.elem(i)=dfy.elem(indxinv(i));
  }

  dfz.save_dvector_derivatives(zpos);

  //ln_unsigned_det=part_prod(ub);
  dfpart_prod(ub)+=df_ln_det;
  df_ln_det=0.0;

  for (int j=ub;j>=lb+1;j--)
  {
    //part_prod(j)=part_prod(j-1)+log(fabs(bb(j,j));
    dfpart_prod(j-1)+=dfpart_prod(j);
    dfb(j,j)+=dfpart_prod(j)/b(j,j);
    dfpart_prod(j)=0.0;
  }

  //part_prod(lb)=log(fabs(bb(lb,lb));
  dfb(lb,lb)+=dfpart_prod(lb)/b(lb,lb);
  dfpart_prod(lb)=0.0;

  for (int j=ub;j>=lb;j--)
  {
    for (int i=ub;i>=lb;i--)
    {
      if (i<=j)
      {
        // b.elem(i,j)=sum;
        dfsum+=dfb.elem(i,j);
        dfb.elem(i,j)=0.;
      }
      else
      {
        // b.elem(i,j)=sum/b.elem(j,j);
        dfsum+=dfb.elem(i,j)/b.elem(j,j);
        dfb.elem(j,j)-=dfb.elem(i,j)*b.elem(i,j)/b.elem(j,j);
        dfb.elem(i,j)=0.;
      }

      for (int k=min(i-1,j-1);k>=lb;k--)
      {
        // sum-=b.elem(i,k)*b.elem(k,j);
        dfb.elem(i,k)-=dfsum*b.elem(k,j);
        dfb.elem(k,j)-=dfsum*b.elem(i,k);
      }
      // sum=value(a(indx.elem(i),j);
      save_dmatrix_derivatives(a_pos,dfsum,indx.elem(i),j); // like this
      dfsum=0.;
    }
  }
}
#undef TINY

void dvdm_prod(void);
void dvcm_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const dvar_vector& x, const dvar_matrix& m)
 {
   gradient_structure* gs = gradient_structure::_instance;
   DF_FILE* fp = gradient_structure::fp;
   gs->RETURN_ARRAYS_INCREMENT();

   if (x.indexmin() != m.rowmin() || x.indexmax() != m.rowmax())
   {
     cerr << " Incompatible array bounds in "
     "dvar_vector operator*(const dvar_matrix& m, const dvar_vector& x)\n";
     ad_exit(21);
   }

   kkludge_object kkk;
   dvar_vector tmp(m.colmin(),m.colmax(),kkk);
   double sum;
   for (int j=m.colmin(); j<=m.colmax(); j++)
   {
     sum=0.0;
     for (int i=x.indexmin(); i<=x.indexmax(); i++)
     {
       //sum+=x[i]*m[i][j];
       sum+=x.elem_value(i)*(m.elem(i)).elem_value(j);
     }
     tmp.elem_value(j)=sum;
   }

  save_identifier_string("PLACE4");
  fp->save_dvar_vector_value(x);
  fp->save_dvar_vector_position(x);
  save_identifier_string("PLACE3");
  fp->save_dvar_matrix_value(m);
  fp->save_dvar_matrix_position(m);
  save_identifier_string("PLACE2");
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("PLACE1");
  gs->GRAD_STACK1->set_gradient_stack(dvdm_prod);
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
void dvdm_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("PLACE1");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  verify_identifier_string("PLACE2");
  dvar_matrix_position m_pos=fp->restore_dvar_matrix_position();
  dmatrix m=fp->restore_dvar_matrix_value(m_pos);
  verify_identifier_string("PLACE3");
  dvar_vector_position x_pos=fp->restore_dvar_vector_position();
  dvector x=restore_dvar_vector_value(x_pos);
  verify_identifier_string("PLACE4");
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);

  dmatrix dfm(m_pos);
  dvector dfx(x_pos.indexmin(),x_pos.indexmax());
  dfm.initialize();
  dfx.initialize();

   double dfsum;
   for (int j=m.colmax(); j>=m.colmin(); j--)
   {
     //tmp.elem_value(j)=sum;
     dfsum=dftmp.elem(j);
     for (int i=x.indexmax(); i>=x.indexmin(); i--)
     {
       //sum+=x[i]*m[i][j];
       //sum+=x.elem_value(i)*(m.elem(i)).elem_value(j);
       dfm.elem(i,j)+=dfsum*x.elem(i);
       dfx.elem(i)+=dfsum*m.elem(i,j);
     }
     //sum=0.0;
     dfsum=0.0;
   }
   dfx.save_dvector_derivatives(x_pos);
   dfm.save_dmatrix_derivatives(m_pos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const dvar_vector& x, const dmatrix& m)
 {
   gradient_structure* gs = gradient_structure::_instance;
   DF_FILE* fp = gradient_structure::fp;
   gs->RETURN_ARRAYS_INCREMENT();

   if (x.indexmin() != m.rowmin() || x.indexmax() != m.rowmax())
   {
     cerr << " Incompatible array bounds in "
     "dvar_vector operator*(const dvar_matrix& m, const dvar_vector& x)\n";
     ad_exit(21);
   }

   kkludge_object kkk;
   dvar_vector tmp(m.colmin(),m.colmax(),kkk);
   double sum;
   for (int j=m.colmin(); j<=m.colmax(); j++)
   {
     sum=0.0;
     for (int i=x.indexmin(); i<=x.indexmax(); i++)
     {
       //sum+=x[i]*m[i][j];
       sum+=x.elem_value(i)*(m.elem(i)).elem(j);
     }
     tmp.elem_value(j)=sum;
   }

  save_identifier_string("P4");
  fp->save_dvar_vector_position(x);
  save_identifier_string("PLACE3");
  fp->save_dmatrix_value(m);
  fp->save_dmatrix_position(m);
  save_identifier_string("PLACE2");
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("PLACE1");
  gs->GRAD_STACK1->set_gradient_stack(dvcm_prod);
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
void dvcm_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("PLACE1");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  verify_identifier_string("PLACE2");
  dvar_matrix_position m_pos=fp->restore_dvar_matrix_position();
  dmatrix m=fp->restore_dvar_matrix_value(m_pos);
  verify_identifier_string("PLACE3");
  dvar_vector_position x_pos=fp->restore_dvar_vector_position();
  verify_identifier_string("P4");
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);

  dvector dfx(x_pos.indexmin(),x_pos.indexmax());
  dfx.initialize();

   double dfsum;
   int imax=dfx.indexmax();
   int imin=dfx.indexmin();
   for (int j=m.colmax(); j>=m.colmin(); j--)
   {
     //tmp.elem_value(j)=sum;
     dfsum=dftmp.elem(j);
     for (int i=imax; i>=imin; i--)
     {
       //sum+=x[i]*m[i][j];
       //sum+=x.elem_value(i)*(m.elem(i)).elem_value(j);
       dfx.elem(i)+=dfsum*m.elem(i,j);
     }
     //sum=0.0;
     dfsum=0.0;
   }
   dfx.save_dvector_derivatives(x_pos);
}

void dmdv_prod(void);
void cmdv_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const dvar_matrix& m, const dvar_vector& x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

#ifndef OPT_LIB
  if (x.indexmin() != m.colmin() || x.indexmax() != m.colmax())
  {
     cerr << " Incompatible array bounds in "
     "dvar_vector operator*(const dvar_matrix& m, const dvar_vector& x)\n";
     ad_exit(21);
  }
#endif

  kkludge_object kkk;
  dvar_vector tmp(m.rowmin(),m.rowmax(),kkk);
  for (int i=m.rowmin(); i<=m.rowmax(); i++)
  {
    double sum = 0.0;
    for (int j=x.indexmin(); j<=x.indexmax(); j++)
    {
       //sum+=m[i][j]*x[j];
       sum+=(m.elem(i)).elem_value(j)*x.elem_value(j);
    }
    tmp.elem_value(i)=sum;
  }

  DF_FILE* fp = gradient_structure::fp;
#ifndef OPT_LIB
  save_identifier_string("PLACE4");
#endif
  fp->save_dvar_vector_value(x);
  fp->save_dvar_vector_position(x);
#ifndef OPT_LIB
  save_identifier_string("PLACE3");
#endif
  fp->save_dvar_matrix_value(m);
  fp->save_dvar_matrix_position(m);
#ifndef OPT_LIB
  save_identifier_string("PLACE2");
#endif
  fp->save_dvar_vector_position(tmp);
#ifndef OPT_LIB
  save_identifier_string("PLACE1");
#endif
  gs->GRAD_STACK1->set_gradient_stack(dmdv_prod);
  gs->RETURN_ARRAYS_DECREMENT();
  return(tmp);
}

/**
 * Description not yet available.
 * \param
 */
void dmdv_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

#ifndef OPT_LIB
  verify_identifier_string("PLACE1");
#endif
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
#ifndef OPT_LIB
  verify_identifier_string("PLACE2");
#endif
  dvar_matrix_position m_pos=fp->restore_dvar_matrix_position();
  dmatrix m=fp->restore_dvar_matrix_value(m_pos);
#ifndef OPT_LIB
  verify_identifier_string("PLACE3");
#endif
  dvar_vector_position x_pos=fp->restore_dvar_vector_position();
  dvector x=restore_dvar_vector_value(x_pos);
#ifndef OPT_LIB
  verify_identifier_string("PLACE4");
#endif
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);

  dmatrix dfm(m_pos);
  dvector dfx(x_pos.indexmin(),x_pos.indexmax());
  dfm.initialize();
  dfx.initialize();

  for (int i=m.rowmax(); i>=m.rowmin(); i--)
  {
    //tmp.elem_value(i)=sum;
    double dfsum=dftmp.elem(i);
    for (int j=x.indexmax(); j>=x.indexmin(); j--)
    {
      //sum+=(m.elem(i)).elem_value(j)*x.elem_value(j);
      dfm.elem(i,j)+=dfsum*x.elem(j);
      dfx.elem(j)+=dfsum*m.elem(i,j);
    }
    //sum=0.0;
    dfsum=0.0;
  }
  dfx.save_dvector_derivatives(x_pos);
  dfm.save_dmatrix_derivatives(m_pos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const dmatrix& m, const dvar_vector& x)
{
  gradient_structure* gs = gradient_structure::_instance;

  gs->RETURN_ARRAYS_INCREMENT();

#ifndef OPT_LIB
  if (x.indexmin() != m.colmin() || x.indexmax() != m.colmax())
  {
    cerr << " Incompatible array bounds in "
    "dvar_vector operator*(const dvar_matrix& m, const dvar_vector& x)\n";
    ad_exit(21);
  }
#endif

  kkludge_object kkk;
  dvar_vector tmp(m.rowmin(),m.rowmax(),kkk);
  for (int i=m.rowmin(); i<=m.rowmax(); i++)
  {
    double sum=0.0;
    for (int j=x.indexmin(); j<=x.indexmax(); j++)
    {
      //sum+=m[i][j]*x[j];
      sum+=(m.elem(i)).elem(j)*x.elem_value(j);
    }
    tmp.elem_value(i)=sum;
  }

  DF_FILE* fp = gradient_structure::fp;
#ifndef OPT_LIB
  save_identifier_string("PLACE4");
#endif
  fp->save_dvar_vector_value(x);
  fp->save_dvar_vector_position(x);
  fp->save_dmatrix_value(m);
  fp->save_dmatrix_position(m);
#ifndef OPT_LIB
  save_identifier_string("PLACE2");
#endif
  fp->save_dvar_vector_position(tmp);
#ifndef OPT_LIB
  save_identifier_string("PLACE1");
#endif
  gs->GRAD_STACK1->set_gradient_stack(cmdv_prod);
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void cmdv_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

#ifndef OPT_LIB
  verify_identifier_string("PLACE1");
#endif
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
#ifndef OPT_LIB
  verify_identifier_string("PLACE2");
#endif
  dmatrix_position m_pos=fp->restore_dmatrix_position();
  dmatrix m=fp->restore_dmatrix_value(m_pos);
  dvar_vector_position x_pos=fp->restore_dvar_vector_position();
  dvector x=restore_dvar_vector_value(x_pos);
#ifndef OPT_LIB
  verify_identifier_string("PLACE4");
#endif
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);

  dvector dfx(x_pos.indexmin(),x_pos.indexmax());
  dfx.initialize();
  for (int i=m.rowmax(); i>=m.rowmin(); i--)
  {
    // tmp.elem_value(i)=sum;
    double dfsum=dftmp.elem(i);
    for (int j=x.indexmax(); j>=x.indexmin(); j--)
    {
      //sum+=(m.elem(i)).elem(j)*x.elem_value(j);
      dfx.elem(j)+=dfsum*m.elem(i,j);
    }
    //sum=0.0;
    dfsum=0.0;
  }
  dfx.save_dvector_derivatives(x_pos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator-(const dvar_matrix& m1, const dmatrix& m2 )
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

#ifndef OPT_LIB
  if (m1.colmin() != m2.colmin() || m1.colmax() != m2.colmax())
  {
    cerr << " Incompatible array bounds in "
     "dvar_matrix operator+(const dvar_matrix& x, const dmatrix& m)\n";
    ad_exit(21);
  }
#endif

  int min = m1.rowmin();
  int max = m1.rowmax();
  dvar_matrix tmp;
  tmp.allocate(min, max);

  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pm1i = &m1(min);
  const dvector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = *pm1i - *pm2i;

    ++ptmpi;
    ++pm1i;
    ++pm2i;
  }

  gs->RETURN_ARRAYS_DECREMENT();

  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator-(const dvar_matrix& m1, const dvar_matrix& m2)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

#ifndef OPT_LIB
  if (m1.colmin() != m2.colmin() || m1.colmax() != m2.colmax())
  {
     cerr << " Incompatible array bounds in "
     "dvar_matrix operator+(const dvar_matrix& x, const dvar_matrix& m)\n";
     ad_exit(21);
  }
#endif

  int min = m1.rowmin();
  int max = m1.rowmax();
  dvar_matrix tmp;
  tmp.allocate(min, max);

  dvar_vector* ptmpi = &tmp(min);
  const dvar_vector* pm1i = &m1(min);
  const dvar_vector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = *pm1i - *pm2i;

    ++ptmpi;
    ++pm1i;
    ++pm2i;
  }

  gs->RETURN_ARRAYS_DECREMENT();

  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator-(const dmatrix& m1, const dvar_matrix& m2)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

#ifndef OPT_LIB
  if (m1.colmin() != m2.colmin() || m1.colmax() != m2.colmax())
  {
     cerr << " Incompatible array bounds in "
     "dvar_matrix operator+(const dmatrix& x, const dvar_matrix& m)\n";
     ad_exit(21);
  }
#endif

  int min = m1.rowmin();
  int max = m1.rowmax();
  dvar_matrix tmp;
  tmp.allocate(min, max);

  dvar_vector* ptmpi = &tmp(min);
  const dvector* pm1i = &m1(min);
  const dvar_vector* pm2i = &m2(min);
  for (int i = min; i <= max; ++i)
  {
    *ptmpi = *pm1i - *pm2i;

    ++ptmpi;
    ++pm1i;
    ++pm2i;
  }

  gs->RETURN_ARRAYS_DECREMENT();

  return tmp;
}
#ifdef DEBUG
  #include <cassert>
  #include <climits>
#endif
#ifdef __TURBOC__
  #pragma hdrstop
  #include <iomanip.h>
#endif

#ifdef __ZTC__
  #include <iomanip.hpp>
#endif

#define TINY 1.0e-20;
void dfinvpret(void);

// int min(int a,int b);
void df_xdet(void);

/** Determinaant of matrix.
    \param aa dvar_matrix containing a square matrix,\f$A\f$.
    \return \f$\det(A)\f$.
    \n\n The implementation of this algorithm was inspired by
    "Numerical Recipes in C", 2nd edition,
    Press, Teukolsky, Vetterling, Flannery, chapter 2

    Edited by Steve Martell on Dec 30, 2013 to address a bug
    where the lower bound of the square dvar_matrix was greater than 1.
*/
dvariable det(const dvar_matrix& aa)
{
  int i,j,k;
#if defined(DEBUG) && (__cplusplus >= 201103L)
  int n = [](unsigned int colsize) -> int
  {
    assert(colsize <= INT_MAX);
    return static_cast<int>(colsize);
  } (aa.colsize());
#else
  int n = static_cast<int>(aa.colsize());
#endif
  int lb=aa.colmin();
  int ub=aa.colmax();
  ivector indx(lb,ub);
  if (lb!=aa.rowmin()||ub!=aa.colmax())
  {
    cerr << "Error matrix not square in det()"<<endl;
    ad_exit(1);
  }
  int One=1;
  indx.fill_seqadd(lb,One);
  double d;
  double big,dum,sum,temp;
  dvar_matrix_position dmp(aa,1);
  dmatrix bb=value(aa);
  dvector vv(lb,ub);
  dvector part_prod(lb,ub);

  d=1.0;
  for (i=lb;i<=ub;i++)
  {
    big=0.0;
    for (j=lb;j<=ub;j++)
    {
      temp=fabs(bb.elem(i,j));
      if (temp > big)
      {
        big=temp;
      }
    }
    if (big == 0.0)
    {
      cerr << "Error in matrix inverse -- matrix singular in inv(dmatrix)\n";
    }
    vv[i]=1.0/big;
  }

  for (j=lb;j<=ub;j++)
  {
    for (i=lb;i<j;i++)
    {
      sum=bb.elem(i,j);
      for (k=lb;k<i;k++)
      {
        sum = sum - bb.elem(i,k)*bb.elem(k,j);
      }
      //a[i][j]=sum;
      bb(i,j)=sum;
    }
    int imax = j;
    big=0.0;
    for (i=j;i<=ub;i++)
    {
      sum=bb.elem(i,j);
      for (k=lb;k<j;k++)
      {
        sum = sum - bb(i,k)*bb(k,j);
      }
      bb(i,j)=sum;
      dum=vv.elem(i)*fabs(sum);
      if ( dum >= big)
      {
        big=dum;
        imax=i;
      }
    }
    if (j != imax)
    {
      for (k=lb;k<=ub;k++)
      {
        dum=bb.elem(imax,k);
        bb.elem(imax,k)=bb.elem(j,k);
        bb.elem(j,k)=dum;
      }
      d = -1.*d;
      vv.elem(imax)=vv.elem(j);

      //if (j<ub)
      {
        int itemp=indx.elem(imax);
        indx.elem(imax)=indx.elem(j);
        indx.elem(j)=itemp;
      }
      //cout << "indx= " <<indx<<endl;
    }

    if (bb.elem(j,j) == 0.0)
    {
      bb(j,j)=TINY;
    }

    if (j != n)
    {
      dum=1.0/bb(j,j);
      for (i=j+1;i<=ub;i++)
      {
        bb.elem(i,j) *= dum;
      }
    }
  }
  //double det=d;
  // SM Bug 129, issue appears to be at this line
  // part_prod is declared above as dvector(lb,ub)
  // cout<<"Bug 129 ="<<part_prod(lb)<<endl;
  // part_prod(1)=d*bb(1,1);  // replaced this line with:
  part_prod(lb) = d*bb(lb,lb);
  // cout<<"Ok got this far; det = "<<det<<endl;
  for (j=lb+1;j<=ub;j++)
  {
    part_prod(j)=part_prod(j-1)*bb(j,j);
  }
  double det=part_prod(ub);
  dvariable rdet=nograd_assign(det);
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("PLACE7");
  fp->save_dvector_value(part_prod);
  fp->save_dvector_position(part_prod);
  fp->save_ivector_value(indx);
  fp->save_ivector_position(indx);
  save_identifier_string("PLACE3");
  fp->save_dvar_matrix_position(aa);
  save_identifier_string("PLACE2b");
  fp->save_prevariable_position(rdet);
  save_identifier_string("PLACE2a");
  fp->save_dmatrix_value(bb);
  save_identifier_string("PLACE2");
  fp->save_dmatrix_position(bb);
  save_identifier_string("PLACE1");
  fp->save_double_value(d);
  save_identifier_string("PLACE0");
  gs->GRAD_STACK1->set_gradient_stack(df_xdet);
  return rdet;
}

/** Adjoint code for dvariable det(const dvar_matrix& aa) */
void df_xdet(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("PLACE0");
  double d=fp->restore_double_value();
  verify_identifier_string("PLACE1");
  dmatrix_position bpos=fp->restore_dmatrix_position();
  verify_identifier_string("PLACE2");
  dmatrix b=fp->restore_dmatrix_value(bpos);
  verify_identifier_string("PLACE2a");
  //dvar_matrix_position rdet_pos=restore_prevariable_position();
  double dfdet=fp->restore_prevariable_derivative();
  verify_identifier_string("PLACE2b");
  dvar_matrix_position a_pos=fp->restore_dvar_matrix_position();
  verify_identifier_string("PLACE3");
  ivector_position indx_pos=fp->restore_ivector_position();
  ivector indx=restore_ivector_value(indx_pos);
  dvector_position part_prod_pos=fp->restore_dvector_position();
  dvector part_prod=fp->restore_dvector_value(part_prod_pos);
  verify_identifier_string("PLACE7");
  int lb=b.colmin();
  int ub=b.colmax();
  dmatrix dfb(lb,ub,lb,ub);

  dvector dfpart_prod(lb,ub);

  #ifndef SAFE_INITIALIZE
    dfb.initialize();
    dfpart_prod.initialize();
  #endif


  dfpart_prod(ub)=dfdet;
  int j;
  for (j=ub;j>=lb+1;j--)
  {
    // part_prod(j)=part_prod(j-1)*b(j,j);
    dfpart_prod(j-1)+=dfpart_prod(j)*b(j,j);
    dfb(j,j)+=dfpart_prod(j)*part_prod(j-1);
    dfpart_prod(j)=0.;
  }
  //part_prod(1)=d*b(lb,lb);
  dfb(lb,lb)+=dfpart_prod(lb)*d;
  dfpart_prod(lb)=0.;

  double dfsum=0.;
  for (j=ub;j>=lb;j--)
  {
    for (int i=ub;i>=lb;i--)
    {
      if (i<=j)
      {
        // b(i,j)=sum;
        dfsum+=dfb(i,j);
        dfb(i,j)=0.;
      }
      else
      {
        // b(i,j)=sum/b(j,j);
        dfsum+=dfb(i,j)/b(j,j);
        dfb(j,j)-=dfb(i,j)*b(i,j)/b(j,j);
        dfb(i,j)=0.;
      }

      for (int k=min(i-1,j-1);k>=lb;k--)
      {
        // sum-=b(i,k)*b(k,j);
        dfb(i,k)-=dfsum*b(k,j);
        dfb(k,j)-=dfsum*b(i,k);
      }
      // sum=value(a(indx(i),j);
      save_dmatrix_derivatives(a_pos,dfsum,indx(i),j); // like this
      dfsum=0.;
    }
  }
}

#undef TINY

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

void dmcm_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator*(const dvar_matrix& m1, const dmatrix& cm2)
 {
   if (m1.colmin() != cm2.rowmin() || m1.colmax() != cm2.rowmax())
   {
     cerr << " Incompatible array bounds in "
     "dmatrix operator*(const dvar_matrix& x, const dmatrix& m)\n";
     ad_exit(21);
   }
   dmatrix cm1=value(m1);
   //dmatrix cm2=value(m2);
   dmatrix tmp(m1.rowmin(),m1.rowmax(), cm2.colmin(), cm2.colmax());
   const unsigned int rowsize = cm2.rowsize();
   try
   {
     double* temp_col = new double[rowsize];
     temp_col-=cm2.rowmin();
     for (int j=cm2.colmin(); j<=cm2.colmax(); j++)
     {
       for (int k=cm2.rowmin(); k<=cm2.rowmax(); k++)
       {
         temp_col[k] = cm2.elem(k,j);
       }
       for (int i=cm1.rowmin(); i<=cm1.rowmax(); i++)
       {
         double sum=0.0;
         dvector& temp_row = cm1(i);
         for (int k=cm1.colmin(); k<=cm1.colmax(); k++)
         {
           sum+=temp_row(k) * (temp_col[k]);
           // sum+=temp_row(k) * cm2(k,j);
         }
         tmp(i,j)=sum;
       }
     }
     temp_col+=cm2.rowmin();
     delete [] temp_col;
     temp_col = 0;
   }
   catch (std::bad_alloc& e)
   {
     cerr << "Error[" << __FILE__ << ':' << __LINE__
          << "]: Unable to allocate array.\n";
     //ad_exit(21);
     throw e;
   }
   dvar_matrix vtmp=nograd_assign(tmp);
   gradient_structure* gs = gradient_structure::_instance;
   DF_FILE* fp = gradient_structure::fp;
   save_identifier_string("TEST1");
   //m1.save_dvar_matrix_value();
   fp->save_dvar_matrix_position(m1);
   fp->save_dmatrix_value(cm2);
   fp->save_dmatrix_position(cm2);
   fp->save_dvar_matrix_position(vtmp);
   save_identifier_string("TEST6");
   gs->GRAD_STACK1->set_gradient_stack(dmcm_prod);
   return vtmp;
 }

/**
 * Description not yet available.
 * \param
 */
void dmcm_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("TEST6");
  dvar_matrix_position vpos=fp->restore_dvar_matrix_position();
  dmatrix dftmp=restore_dvar_matrix_derivatives(vpos);
  dmatrix_position m2pos=fp->restore_dmatrix_position();
  dmatrix cm2=fp->restore_dmatrix_value(m2pos);
  dvar_matrix_position m1pos=fp->restore_dvar_matrix_position();
  //dmatrix cm1=restore_dvar_matrix_value(m1pos);
  verify_identifier_string("TEST1");
  dmatrix dfm1(m1pos);
  double dfsum;
  dfm1.initialize();
  for (int j=cm2.colmin(); j<=cm2.colmax(); j++)
  {
    for (int i=dfm1.rowmin(); i<=dfm1.rowmax(); i++)
    {
      //tmp.elem(i,j)=sum;
      dfsum=dftmp.elem(i,j);
      for (int k=dfm1.colmin(); k<=dfm1.colmax(); k++)
      {
        //sum+=cm1(i,k) * cm2(k,j);
        dfm1.elem(i,k)+=dfsum * cm2.elem(k,j);
        //dfm2.elem(k,j)+=dfsum * cm1.elem(i,k);
      }
    }
  }
  dfm1.save_dmatrix_derivatives(m1pos);
  //dfm2.save_dmatrix_derivatives(m2pos);
  // cout << "leaving dmdm_prod"<<endl;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

void cmdm_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_matrix operator*(const dmatrix& cm1, const dvar_matrix& m2)
 {
   if (cm1.colmin() != m2.rowmin() || cm1.colmax() != m2.rowmax())
   {
     cerr << " Incompatible array bounds in "
     "dmatrix operator*(const dmatrix& x, const dvar_matrix& m)\n";
     ad_exit(21);
   }
   dmatrix cm2=value(m2);
   dmatrix tmp(cm1.rowmin(),cm1.rowmax(), m2.colmin(), m2.colmax());

   const unsigned int rowsize = m2.rowsize();
   try
   {
     double* temp_col = new double[rowsize];

     temp_col-=cm2.rowmin();

     for (int j=cm2.colmin(); j<=cm2.colmax(); j++)
     {
       for (int k=cm2.rowmin(); k<=cm2.rowmax(); k++)
       {
         temp_col[k] = cm2.elem(k,j);
       }
       for (int i=cm1.rowmin(); i<=cm1.rowmax(); i++)
       {
         double sum=0.0;
         const dvector& temp_row = cm1(i);
         for (int k=cm1.colmin(); k<=cm1.colmax(); k++)
         {
            sum+=temp_row(k) * (temp_col[k]);
           // sum+=temp_row(k) * cm2(k,j);
         }
         tmp(i,j)=sum;
       }
     }
     temp_col+=cm2.rowmin();
     delete [] temp_col;
     temp_col = 0;
   }
   catch (std::bad_alloc& e)
   {
     cerr << "Error[" << __FILE__ << ':' << __LINE__
          << "]: Unable to allocate array.\n";
     //ad_exit(21);
     throw e;
   }

   gradient_structure* gs = gradient_structure::_instance;
   DF_FILE* fp = gradient_structure::fp;
   dvar_matrix vtmp=nograd_assign(tmp);
   save_identifier_string("TEST1");
   fp->save_dmatrix_value(cm1);
   fp->save_dmatrix_position(cm1);
   // m2.save_dvar_matrix_value();
   fp->save_dvar_matrix_position(m2);
   fp->save_dvar_matrix_position(vtmp);
   save_identifier_string("TEST6");
   gs->GRAD_STACK1->set_gradient_stack(cmdm_prod);
   return vtmp;
 }

/**
 * Description not yet available.
 * \param
 */
void cmdm_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("TEST6");
  dvar_matrix_position vpos=fp->restore_dvar_matrix_position();
  dmatrix dftmp=restore_dvar_matrix_derivatives(vpos);
  dvar_matrix_position m2pos=fp->restore_dvar_matrix_position();
  //dmatrix cm2=restore_dvar_matrix_value(m2pos);
  dmatrix_position m1pos=fp->restore_dmatrix_position();
  dmatrix cm1=fp->restore_dmatrix_value(m1pos);
  verify_identifier_string("TEST1");
  //dmatrix dfm1(m1pos);
  dmatrix dfm2(m2pos);
  double dfsum;
  dfm2.initialize();
  for (int j=dfm2.colmin(); j<=dfm2.colmax(); j++)
  {
    for (int i=cm1.rowmin(); i<=cm1.rowmax(); i++)
    {
      //tmp.elem(i,j)=sum;
      dfsum=dftmp.elem(i,j);
      for (int k=cm1.colmin(); k<=cm1.colmax(); k++)
      {
        //sum+=cm1(i,k) * cm2(k,j);
       //dfm1.elem(i,k)+=dfsum * cm2.elem(k,j);
        dfm2.elem(k,j)+=dfsum * cm1.elem(i,k);
      }
    }
  }
  //dfm1.save_dmatrix_derivatives(m1pos);
  dfm2.save_dmatrix_derivatives(m2pos);
  // cout << "leaving dmdm_prod"<<endl;
}
#ifdef DEBUG
  #include <cassert>
  #include <climits>
#endif

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

#define TINY 1.0e-20;
void dfinvpret(void);

/**
Return smallest value of two integers a or b
\param a An integer
\param b An integer
\return A integer \f$ z = \min(a,b)\f$
*/
int min(const int a, const int b)
{
  return a <= b ? a : b;
}

/** Inverse of a varaiable matrix.
    \param aa dvar_matrix conaining matrix to be inverted,\f$A\f$.
    \return dvar_matrix containing \f$A^{-1}\f$.
    \n\n The implementation of this algorithm was inspired by
    "Numerical Recipes in C", 2nd edition,
    Press, Teukolsky, Vetterling, Flannery, chapter 2
*/
dvar_matrix inv(const dvar_matrix& aa)
{
  int imax = 0;
#if defined(DEBUG) && (__cplusplus >= 201103L)
  int n = [](unsigned int colsize) -> int
  {
    assert(colsize <= INT_MAX);
    return static_cast<int>(colsize);
  } (aa.colsize());
#else
  int n = static_cast<int>(aa.colsize());
#endif
  int lb=aa.colmin();
  int ub=aa.colmax();
  dvar_matrix vc(lb,ub,lb,ub);
  if (n==1)
  {
    if (aa(lb,lb)==0.0)
    {
      cerr << "Error in matrix inverse -- matrix singular in inv(dmatrix)\n";
      ad_exit(1);
    }
    else
    {
      vc(lb,lb)=1.0/aa(lb,lb);
      return vc;
    }
  }
  ivector indx(lb,ub);
  int One=1;
  indx.fill_seqadd(lb,One);
  double d;
  double big,dum,sum,temp;
  dvar_matrix_position dmp(aa,0);
  dmatrix bb=value(aa);
  dvector vv(lb,ub);

  d=1.0;
  for (int i=lb;i<=ub;i++)
  {
    big=0.0;
    for (int j=lb;j<=ub;j++)
    {
      temp=fabs(bb.elem(i,j));
      if (temp > big)
      {
        big=temp;
      }
    }
    if (big == 0.0)
    {
      cerr << "Error in matrix inverse -- matrix singular in inv(dmatrix)\n";
      ad_exit(1);
    }
    vv[i]=1.0/big;
  }

  for (int j=lb;j<=ub;j++)
  {
    for (int i=lb;i<j;i++)
    {
      sum=bb.elem(i,j);
      for (int k=lb;k<i;k++)
      {
        sum = sum - bb.elem(i,k)*bb.elem(k,j);
      }
      //a[i][j]=sum;
      bb.elem(i,j)=sum;
    }
    big=0.0;
    for (int i=j;i<=ub;i++)
    {
      sum=bb.elem(i,j);
      for (int k=lb;k<j;k++)
      {
        sum = sum - bb.elem(i,k)*bb.elem(k,j);
      }
      bb.elem(i,j)=sum;
      dum=vv[i]*fabs(sum);
      if ( dum >= big)
      {
        big=dum;
        imax=i;
      }
    }
    if (j != imax)
    {
      for (int k=lb;k<=ub;k++)
      {
        dum=bb.elem(imax,k);
        bb.elem(imax,k)=bb.elem(j,k);
        bb.elem(j,k)=dum;
      }
      d = -1.*d;
      vv[imax]=vv[j];

      //if (j<ub)
      {
        int itemp=indx.elem(imax);
        indx.elem(imax)=indx.elem(j);
        indx.elem(j)=itemp;
      }
      //cout << "indx= " <<indx<<endl;
    }

    if (bb.elem(j,j) == 0.0)
    {
      bb.elem(j,j)=TINY;
    }

    if (j != n)
    {
      dum=1.0/bb.elem(j,j);
      for (int i=j+1;i<=ub;i++)
      {
        bb.elem(i,j) = bb.elem(i,j) * dum;
      }
    }
  }

  dvector y(lb,ub);
  dvector x(lb,ub);
  //int lb=rowmin;
  //int ub=rowmax;
  dmatrix& b=bb;
  ivector indxinv(lb,ub);
  for (int i=lb;i<=ub;i++)
  {
    indxinv(indx.elem(i))=i;
  }

  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;

  for (int ii=lb;ii<=ub;ii++)
  {
    y.initialize();
    y(indxinv(ii))=1.;
    for (int i=indxinv(ii);i<=ub;i++)
    {
      // sum=y(ii,i);
      if (i==indxinv(ii))
      {
        sum=1.;
      }
      else
      {
        sum=0.;
      }
      for (int j=indxinv(ii);j<=i-1;j++)
      {
        sum-=b.elem(i,j)*y.elem(j);
      }
      y.elem(i)=sum;
    }
    for (int i=ub;i>=lb;i--)
    {
      sum=y.elem(i);
      for (int j=i+1;j<=ub;j++)
      {
        sum-=b.elem(i,j)*x.elem(j);
      }
      x.elem(i)=sum/b.elem(i,i);
    }
    fp->save_dvector_value(y);
    fp->save_dvector_value(x);
    nograd_assign_column(vc,x,ii);
  }

#ifndef OPT_LIB
  save_identifier_string("P5");
#endif
  fp->save_dvector_position(x);
  fp->save_dvector_position(y);
  fp->save_ivector_value(indx);
  fp->save_ivector_position(indx);
  fp->save_dvar_matrix_position(aa);
  fp->save_dvar_matrix_position(vc);
  fp->save_dmatrix_value(bb);
  fp->save_dmatrix_position(bb);
#ifndef OPT_LIB
  save_identifier_string("P1");
#endif
  gs->GRAD_STACK1->set_gradient_stack(dfinvpret);
  return vc;
}

/** Adjoint code for dvar_matrix inv(const dvar_matrix& aa).
*/
void dfinvpret(void)
{
  DF_FILE* fp = gradient_structure::fp;

#ifndef OPT_LIB
  verify_identifier_string("P1");
#endif
  dmatrix_position bpos=fp->restore_dmatrix_position();
  dmatrix b=fp->restore_dmatrix_value(bpos);
  dvar_matrix_position v_pos=fp->restore_dvar_matrix_position();
  dvar_matrix_position a_pos=fp->restore_dvar_matrix_position();
  ivector_position indx_pos=fp->restore_ivector_position();
  ivector indx=restore_ivector_value(indx_pos);
  dvector_position y_pos=fp->restore_dvector_position();
  dvector_position x_pos=fp->restore_dvector_position();
#ifndef OPT_LIB
  verify_identifier_string("P5");
#endif
  int lb=b.colmin();
  int ub=b.colmax();
  dmatrix dfb(lb,ub,lb,ub);
  ivector indxinv(lb,ub);
  for (int i=lb;i<=ub;i++)
  {
    indxinv(indx.elem(i))=i;
  }

  double dfsum=0.;
  dvector dfy(lb,ub);
  #ifndef SAFE_INITIALIZE
    dfb.initialize();
    dfy.initialize();
  #endif
  for (int ii=ub;ii>=lb;ii--)
  {
    //x.save_dvector_value();
    dvector x=fp->restore_dvector_value(x_pos);
    //y.save_dvector_value();
    dvector y=fp->restore_dvector_value(y_pos);
    dvector dfx=restore_dvar_matrix_derivative_column(v_pos,ii);
    for (int i=lb;i<=ub;i++)
    {
      // x.elem(i)=sum/b.elem(i,i);
      dfsum+=dfx.elem(i)/b.elem(i,i);
      dfb.elem(i,i)-=dfx.elem(i)*x.elem(i)/b.elem(i,i);
      dfx.elem(i)=0.;
      for (int j=ub;j>=i+1;j--)
      {
        // sum -=b.elem(i,j)*x.elem(j);
        dfb.elem(i,j)-=dfsum*x.elem(j);
        dfx.elem(j)-=dfsum*b.elem(i,j);
      }
      // sum=y.elem(i);
      dfy.elem(i)+=dfsum;
      dfsum=0.;
    }

    //for (i=ub;i>=lb;i--)
    int i2;
    for (i2=ub;i2>=indxinv(ii);i2--)
    {
      // y.elem(i)=sum;
      dfsum+=dfy.elem(i2);
      dfy.elem(i2)=0.;
      // for (int j=i-1;j>=lb;j--)
      for (int j=i2-1;j>=indxinv(ii);j--)
      {
        // sum-=b.elem(i,j)*y.elem(j);
        dfb.elem(i2,j)-=dfsum*y.elem(j);
        dfy.elem(j)-=dfsum*b.elem(i2,j);
      }
      //sum=y.elem(i);
      dfy.elem(i2)=dfsum;
      dfsum=0.;
    }
    //x.initialize()
    //y.initialize()
    dfx.initialize();
    dfy.initialize();
  }

  for (int j=ub;j>=lb;j--)
  {
    for (int i=ub;i>=lb;i--)
    {
      if (i<=j)
      {
        // b.elem(i,j)=sum;
        dfsum+=dfb.elem(i,j);
        dfb.elem(i,j)=0.;
      }
      else
      {
        // b.elem(i,j)=sum/b.elem(j,j);
        dfsum+=dfb.elem(i,j)/b.elem(j,j);
        dfb.elem(j,j)-=dfb.elem(i,j)*b.elem(i,j)/b.elem(j,j);
        dfb.elem(i,j)=0.;
      }

      for (int k=min(i-1,j-1);k>=lb;k--)
      {
        // sum-=b.elem(i,k)*b.elem(k,j);
        dfb.elem(i,k)-=dfsum*b.elem(k,j);
        dfb.elem(k,j)-=dfsum*b.elem(i,k);
      }
      // sum=value(a(indx.elem(i),j);
      save_dmatrix_derivatives(a_pos,dfsum,indx.elem(i),j); // like this
      dfsum=0.;
    }
  }
}

#undef TINY

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

/*
 dvar_matrix  operator*(const dvar_matrix& m1, const dvar_matrix& m2 )
 {
   if (m1.colmin() != m2.rowmin() || m1.colmax() != m2.rowmax())
   {
     cerr << " Incompatible array bounds in dmatrix  operator * (const dmatrix& x, const dmatrix& m)\n";
     ad_exit(21);
   }
   //dmatrix cm1=value(m1);
   //dmatrix cm2=value(m2);
   dmatrix tmp(m1.rowmin(),m1.rowmax(), m2.colmin(), m2.colmax());
   double sum;
   double ** temp_col=(double **) malloc(m2.rowsize()*sizeof(double*));
   temp_col-=m2.rowmin();


   for (int j=m2.colmin(); j<=m2.colmax(); j++)
   {

     for (int k=m2.rowmin(); k<=m2.rowmax(); k++)
     {
       temp_col[k] = (double*) &m2.elem_value(k,j);
     }

     for (int i=m1.rowmin(); i<=m1.rowmax(); i++)
     {
       sum=0.0;
       const dvar_vector& temp_row = m1(i);
       for (int k=m1.colmin(); k<=m1.colmax(); k++)
       {
          sum+=temp_row.elem_value(k) * (*temp_col[k]);
         // sum+=temp_row(k) * cm2(k,j);
       }
       tmp(i,j)=sum;
     }
   }


   temp_col+=m2.rowmin();
   free ((char*)temp_col);
   dvar_matrix vtmp=nograd_assign(tmp);
   gradient_structure* gs = gradient_structure::get();
   DF_FILE* fp = gs->fp;
   save_identifier_string("TEST1");
   m1.save_dvar_matrix_value(fp);
   m1.save_dvar_matrix_position(fp);
   m2.save_dvar_matrix_value(fp);
   m2.save_dvar_matrix_position(fp);
   vtmp.save_dvar_matrix_position(fp);
   save_identifier_string("TEST6");
   gs->GRAD_STACK1->set_gradient_stack(dmdm_prod);
   return vtmp;
 }
*/

/**
 * Description not yet available.
 * \param
 */
 dvar_matrix operator*(const dvar_matrix& m1, const dvar_matrix& m2)
 {
   if (m1.colmin() != m2.rowmin() || m1.colmax() != m2.rowmax())
   {
     cerr << " Incompatible array bounds in "
     "dmatrix operator*(const dmatrix& x, const dmatrix& m)\n";
     ad_exit(21);
   }
   //dmatrix cm1=value(m1);
   //dmatrix cm2=value(m2);
   dmatrix tmp(m1.rowmin(),m1.rowmax(), m2.colmin(), m2.colmax());
   double sum;


   for (int j=m2.colmin(); j<=m2.colmax(); j++)
   {
     dvector m2col=column_value(m2,j);

     for (int i=m1.rowmin(); i<=m1.rowmax(); i++)
     {
       sum=value(m1(i))*m2col;
       tmp(i,j)=sum;
     }
   }

   dvar_matrix vtmp=nograd_assign(tmp);
   gradient_structure* gs = gradient_structure::_instance;
   DF_FILE* fp = gradient_structure::fp;
   save_identifier_string("TEST1");
   fp->save_dvar_matrix_value(m1);
   fp->save_dvar_matrix_position(m1);
   fp->save_dvar_matrix_value(m2);
   fp->save_dvar_matrix_position(m2);
   fp->save_dvar_matrix_position(vtmp);
   save_identifier_string("TEST6");
   gs->GRAD_STACK1->set_gradient_stack(dmdm_prod);
   return vtmp;
 }

/**
 * Description not yet available.
 * \param
 */
void dmdm_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("TEST6");
  dvar_matrix_position vpos=fp->restore_dvar_matrix_position();
  dmatrix dftmp=restore_dvar_matrix_derivatives(vpos);
  dvar_matrix_position m2pos=fp->restore_dvar_matrix_position();
  dmatrix cm2=fp->restore_dvar_matrix_value(m2pos);
  dvar_matrix_position m1pos=fp->restore_dvar_matrix_position();
  dmatrix cm1=fp->restore_dvar_matrix_value(m1pos);
  verify_identifier_string("TEST1");
  dmatrix dfm1(m1pos);
  dmatrix dfm2(m2pos);
  double dfsum;
  dfm1.initialize();
  dfm2.initialize();
  for (int j=cm2.colmin(); j<=cm2.colmax(); j++)
  {
    for (int i=cm1.rowmin(); i<=cm1.rowmax(); i++)
    {
      //tmp.elem(i,j)=sum;
      dfsum=dftmp.elem(i,j);
      for (int k=cm1.colmin(); k<=cm1.colmax(); k++)
      {
        //sum+=cm1(i,k) * cm2(k,j);
        dfm1.elem(i,k)+=dfsum * cm2.elem(k,j);
        dfm2.elem(k,j)+=dfsum * cm1.elem(i,k);
      }
    }
  }
  dfm1.save_dmatrix_derivatives(m1pos);
  dfm2.save_dmatrix_derivatives(m2pos);
  // cout << "leaving dmdm_prod"<<endl;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

/**
 * Description not yet available.
 * \param
 */
dmatrix value(const dvar_matrix& m)
{
  int nrl = m.rowmin();
  int nrh = m.rowmax();
  ivector ncl(nrl, nrh);
  ivector nch(nrl, nrh);
  int* pncli = ncl.get_v() + nrl;
  int* pnchi = nch.get_v() + nrl;
  const dvar_vector* pmi = &m(nrl);
  for (int i = nrl; i <= nrh; ++i)
  {
    *pncli = pmi->indexmin();
    *pnchi = pmi->indexmax();

    ++pncli;
    ++pnchi;
    ++pmi;
  }
  dmatrix tmp(nrl, nrh, ncl, nch);
  pmi = &m(nrl);

  dvector* ptmpi = &tmp(nrl);
  for (int i = nrl; i <= nrh; ++i)
  {
    *ptmpi = value(*pmi);

    ++ptmpi;
    ++pmi;
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvariable trace(const dvar_matrix& M)
{
  dvariable tmp;
  tmp=0.0;
  if (M.colmin()!=M.rowmin() || M.colmax()!=M.rowmax() )
  {
    cerr << " Matrix not square in trace\n";
    ad_exit(1);
  }
  for (int i=M.colmin();i<=M.colmax();i++)
  {
    tmp+=M.elem(i,i);
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator+=(const dvar_matrix& m1)
{
  int min = rowmin();
  int max = rowmax();

#ifndef OPT_LIB
  if (min != m1.rowmin() || max != m1.rowmax())
  {
     cerr << " Incompatible array bounds in "
     "dvar_matrix& operator += (const dvar_vector&)\n";
     ad_exit(21);
  }
#endif

  dvar_vector* pmi = m + min;
  const dvar_vector* pm1i = &m1(min);
  for (int i = min; i <= max; ++i)
  {
     *pmi += *pm1i;

     ++pmi;
     ++pm1i;
  }
  return *this;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator+=(const dmatrix& m1)
{
  int min = rowmin();
  int max = rowmax();

#ifndef OPT_LIB
  if (min != m1.rowmin() || max != m1.rowmax())
  {
     cerr << " Incompatible array bounds in "
     "dvar_matrix& operator+=(const dvar_vector&)\n";
     ad_exit(21);
  }
#endif

  dvar_vector* pmi = m + min;
  const dvector* pm1i = &m1(min);
  for (int i = min; i <= max; ++i)
  {
     *pmi += *pm1i;

     ++pmi;
     ++pm1i;
  }
  return *this;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator-=(const dvar_matrix& m1)
{
  int min = rowmin();
  int max = rowmax();

#ifndef OPT_LIB
  if (min != m1.rowmin() || max != m1.rowmax())
  {
     cerr << " Incompatible array bounds in "
     "dvar_matrix& operator -= (const dvar_vector&)\n";
     ad_exit(21);
  }
#endif

  dvar_vector* pmi = m + min;
  const dvar_vector* pm1i = &m1(min);
  for (int i = min; i <= max; ++i)
  {
     *pmi -= *pm1i;

     ++pmi;
     ++pm1i;
  }
  return *this;
}

/**
 * Description not yet available.
 * \param
 */
dvar_matrix& dvar_matrix::operator-=(const dmatrix& m1)
{
  int min = rowmin();
  int max = rowmax();

#ifndef OPT_LIB
  if (min != m1.rowmin() || max != m1.rowmax())
  {
     cerr << " Incompatible array bounds in "
     "dvar_matrix& operator-=(const dvar_vector&)\n";
     ad_exit(21);
  }
#endif

  dvar_vector* pmi = m + min;
  const dvector* pm1i = &m1(min);
  for (int i = min; i <= max; ++i)
  {
     *pmi -= *pm1i;

     ++pmi;
     ++pm1i;
  }
  return *this;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

#include <string.h>
#include <ctype.h>
#ifdef DEBUG
  #include <cassert>
  #include <climits>
#endif

/**
 * Description not yet available.
 * \param
 */
 struct dvec_ptr_ptr
 {
   void ** m;
 };

const int MAXROWS = 5050;

/**
Fill values of dvar_matrix with text input from s with
format rowmin...rowmax where ith row is {colmin,...,colmax}.

Example dvar_matrix::fill("{1,2}{3,4}") produces 
dvar_matrix = 
1 2
3 4
\param s string
*/
void dvar_matrix::fill(const char* s)
{
  const size_t len = strlen(s);
#ifdef DEBUG
  assert(len <= INT_MAX);
#endif
  int n = static_cast<int>(len);
  int braces = 0;
  int nrow = 0;
  int ncol = 0;

  ivector columns(1, MAXROWS);
  ivector k1(1, MAXROWS);
  ivector k2(1, MAXROWS);

  for (int k = 0; k < n; k++)
  {
    if (s[k] == '{')
    {
      braces ++;
      if (braces != 1)
      {
        cerr << "Unbalanced braces in dvar_matrix::fill(const char * s)\n";
        cerr << "at character " << k << "\n";
        ad_exit(1);
      }
      ncol = 1;
      k1[nrow+1] = k;
    }
    else if (s[k] == '}')
    {
      braces --;
      if (braces != 0)
      {
        cerr << "Unbalanced braces in dvar_matrix::fill(const char * s)\n";
        cerr << "at character " << k << "\n";
        ad_exit(1);
      }
      k2[nrow+1] = k;
      nrow ++;
      if (nrow > MAXROWS)
      {
        cerr << "Too many rows in dvar_matrix::fill(const char * s)\n";
        ad_exit(1);
      }
      columns[nrow] = ncol;
    }
    else if (s[k] == ',')
    {
      if (braces != 0)
      {
        ncol++;
      }
    }
  }

  if (braces != 0)
  {
    cerr << "Unbalanced braces in dvar_matrix::fill(const char * s)\n";
    cerr << s << "\n";
    ad_exit(1);
  }

#if defined(__cplusplus) && (__cplusplus >= 201103L)
  [](unsigned int nrow, unsigned int rowsize)
  {
    if (nrow != rowsize)
    {
      if (nrow < rowsize)
      {
        cerr << " Not enough rows in the data for "
        "dvar_matrix::fill(const char*)\n";
        ad_exit(1);
      }
      else
      {
        cerr << " Too many rows in the data for "
        "dvar_matrix::fill(const char*)\n";
        ad_exit(1);
      }
    }
  } (static_cast<unsigned int>(nrow), rowsize());
#endif

  int i;
  for (i=1; i<=nrow; i++)
  {
    unsigned int size = ((*this)[rowmin()+i-1]).size();
    unsigned int column = static_cast<unsigned int>(columns[i]);
    if (size > column)
    {
      cerr << " Not enough columns in the data in row "
           << i << " for dvar_matrix::fill(const char *) \n";
      ad_exit(1);
    }
    else if (size < column)
    {
      cerr << " Too many columns in the data in row "
           << i << " for dvar_matrix::fill(const char *) \n";
      ad_exit(1);
    }
  }

  for (i=rowmin(); i<=rowmax(); i++)
  {
    char * t;
//    t = (char*) new[strlen(s)+1];
    t = new char[strlen(s)+1];

    for (int k = k1[i]; k <= k2[i]; k++)
    {
      t[k-k1[i]] = s[k];
    }
    t[k2[i]-k1[i]+1] = '\0';

    dvector tt(t);
    tt.shift(( (*this)(i)).indexmin() );

    (*this)(i)=tt;

    delete[] t;
    t = 0;
  }
}

#include <stdio.h>
#include <math.h>

/**
 * Description not yet available.
 * \param
 */
dvariable avg( const prevariable& x,const prevariable& y)
{
  return 0.5*(x+y);
}

/*
  prevariable& daves_kludge1(const prevariable& v1)
  {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
      gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    double cx=value(v1);
    double fval;
    double tmp;
    double dftmp;
    double tmp2;
    double tmp3;
    int i=cx;
    if (cx-i <= 0.5)
    {
      tmp=cx-i;
      tmp2=tmp*tmp;
      tmp3=tmp*tmp*tmp;
      fval= 24*tmp3-64*tmp3*tmp+48*tmp3*tmp2;
    }
    else
    {
      tmp=1-(cx-i);
      tmp2=tmp*tmp;
      tmp3=tmp*tmp*tmp;
      fval=1.-24*tmp3+64*tmp3*tmp-48*tmp3*tmp2;
    }

    if (cx-i <= 0.5)
    {
      //fval= 24*tmp3-64*tmp3*tmp+48*tmp3*tmp2;
      double dftmp3=24-64*tmp+48*tmp2;
      dftmp=-64*tmp3;
      double dftmp2=48*tmp3;
      //double tmp3=tmp*tmp*tmp;
      dftmp+=3.*tmp2*dftmp3;
      //double tmp2=tmp*tmp;
      dftmp+=2.*tmp*dftmp2;
    }
    else
    {
      //fval=1.-24*tmp3+64*tmp3*tmp-48*tmp3*tmp2;
      double dftmp3=-24+64*tmp-48*tmp2;
      dftmp=+64*tmp3;
      double dftmp2=-48*tmp3;
      //double tmp3=tmp*tmp*tmp;
      dftmp+=3.*tmp2*dftmp3;
      //double tmp2=tmp*tmp;
      dftmp+=2.*tmp*dftmp2;
      //double tmp=1-(cx-i);
      dftmp=-dftmp;
    }

    gradient_structure::RETURN_PTR->v->x=fval;
    gradient_structure::get()->GRAD_STACK1->set_gradient_stack(default_evaluation,
      &(gradient_structure::RETURN_PTR->v->x), &(v1.v->x),dftmp);
   return(*gradient_structure::RETURN_PTR);
 }
*/

#include <stdio.h>
#include <cmath>

/**
Compute exponential variable

\param v1 is the input value.
\return exponential variable of v1.
*/
prevariable& exp(const prevariable& v1)
{
  //Avoid underflow for large negative values
  // https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/exp-expf
  double tmp = v1.v->x > -708.3964 ?  std::exp(v1.v->x) : 0.0;

#ifdef DIAG
  /** \todo Must remove macros below once support
  for MSVC++11 and Solaris Studio 12.3 are removed.
  */
  #if !defined(__SUNPRO_CC) && !(defined(_MSC_VER) && (_MSC_VER <= 1700))
  if (!std::isfinite(tmp))
  {
    // cerr << "Error: Result of \"exp(prevariable(" << value(v1) << ")) = "
    //      << tmp << "\" is not finite.\n";
    //  ad_exit(1);
  }
  #endif
#endif
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x = tmp;
  gradient_structure::GRAD_STACK1->set_gradient_stack(
    default_evaluation, &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), tmp);

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& atan(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x= ::atan(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), 1./(1.+v1.v->x * v1.v->x));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& ldexp(const prevariable& v1, const int& exponent)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x=::ldexp(v1.v->x, exponent);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x),pow(2.0,exponent));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& sqrt(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  double tmp = v1.v->x;
  if (tmp == 0.0)
  {
    cerr << "Attempting to take the derivative of sqrt(prevariable x)"
         " at x=0\n";
    ad_exit(1);
  }
  tmp = ::sqrt(tmp);

  gradient_structure::_instance->RETURN_PTR->v->x=tmp;
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x),1./(2.*tmp));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
Returns the square of v1.

@param v1 variable
*/
prevariable& sqr(const prevariable& v1)
{
/*
      double tmp=v1.v->x;
      if (tmp==0.0)
      {
        cerr << "Attempting to take the derivative of sqrt(prevariable x)"
         " at x=0\n";
        ad_exit(1);
      }
      tmp=::sqrt(tmp);
      if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;
      gradient_structure::RETURN_PTR->v->x=tmp;
      gradient_structure::get()->GRAD_STACK1->set_gradient_stack(default_evaluation,
        &(gradient_structure::RETURN_PTR->v->x), &(v1.v->x),1./(2.*tmp));
      return(*gradient_structure::RETURN_PTR);
*/
  return pow(v1, 2.0);
}

/**
 * Description not yet available.
 * \param
 */
prevariable& tan(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  double t = ::tan(v1.v->x);

  gradient_structure::_instance->RETURN_PTR->v->x= t;
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), 1+t*t);

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& tanh(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  double t = ::tanh(v1.v->x);

  gradient_structure::_instance->RETURN_PTR->v->x= t;
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), 1.0-t*t);

  return *gradient_structure::_instance->RETURN_PTR;
}
/**
 * Description not yet available.
 * \param
 */
prevariable& acos(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x=::acos(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x),-1./::sqrt(1.- v1.v->x * v1.v->x));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& asin(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x=::asin(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x),1./::sqrt(1.- v1.v->x * v1.v->x));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& pow(const prevariable& v1, const prevariable& v2)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  double x=::pow(v1.v->x,(v2.v->x)-1);
  double y=x* v1.v->x;

  gradient_structure::_instance->RETURN_PTR->v->x=y;
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x),
    &(v1.v->x), v2.v->x * x  ,&(v2.v->x),
    y * ::log(v1.v->x));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& pow(const double u, const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  double y = ::pow(u,(v1.v->x));

  gradient_structure::_instance->RETURN_PTR->v->x=y;
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), y * ::log(u));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& sinh(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x=::sinh(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x),::cosh(v1.v->x));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& cosh(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x=::cosh(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x),::sinh(v1.v->x));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& atan2(const prevariable& v1, const prevariable& v2)
{
  if (value(v1) == 0 && value(v2) == 0)
  {
    cerr << "Error: The ADMB function \"atan2(y, x)\" is undefined "
    "for y and x equal zero.\n";
    ad_exit(1);
  }
  if (value(v1) == 0 && value(v2) > 0)
  {
    return atan(v1/v2);
  }
  dvariable x = (sqrt(v2 * v2 + v1 * v1) - v2)/v1;
  return atan(x) * 2.0;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& atan2(const prevariable& v1, const double v2)
{
  if (value(v1) == 0 && v2 == 0)
  {
    cerr << "Error: The ADMB function \"atan2(y, x)\" is undefined "
    "for y and x equal zero.\n";
    ad_exit(1);
  }
  if (value(v1) == 0 && v2 > 0)
  {
    return atan(v1/v2);
  }
  dvariable x = (sqrt(v2 * v2 + v1 * v1) - v2)/v1;
  return atan(x) * 2.0;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& atan2(const double v1, const prevariable& v2)
{
  if (v1 == 0 && value(v2) == 0)
  {
    cerr << "Error: The ADMB function \"atan2(y, x)\" is undefined "
    "for y and x equal zero.\n";
    ad_exit(1);
  }
  if (v1 == 0 && value(v2) > 0)
  {
    return atan(v1/v2);
  }
  dvariable x = (sqrt(v2 * v2 + v1 * v1) - v2)/v1;
  return atan(x) * 2.0;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
  #include <iomanip.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
  #include <iomanip.hpp>
#endif

#include <stdio.h>
#include <math.h>

/**
 * Description not yet available.
 * \param
 */
prevariable& pow(const prevariable& v1, const double u)
{
#ifndef OPT_LIB
  if (v1.v->x == 0)
  {
    cerr << "Error -- base = 0 in function"
            " prevariable& pow(const prevariable& v1, const double u)" << endl;
  }
#endif

  double x = ::pow(v1.v->x, u-1);
  double y = x * v1.v->x;

  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x = y;
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), u * x);

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
 void prevariable::initialize(void)
 {
   *this = 0.0;
 }

/**
 * Description not yet available.
 * \param
 */
prevariable& sin(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x = ::sin(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), ::cos(v1.v->x) );

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& sigmoid(const prevariable& v1)
{
  double tmp=v1.v->x;

  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  //gradient_structure::RETURN_PTR->v->x=atan(tmp)/1.5708;
  gradient_structure::_instance->RETURN_PTR->v->x=::atan(tmp)/2.8;

  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
     &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x),
 //                1./((1.+tmp*tmp)*1.5708));
                   1./((1.+tmp*tmp)*2.8));
  return *gradient_structure::_instance->RETURN_PTR;
}


    /** \ingroup misc
    Absolute value. Simple overload of standard C library function.
    Not differentiable and should not be used in cases where an
    independent variable is expected to change sign.
    Use \ref sfabs in such cases.
    \param v1 Indpendent variable \f$x\f$
    \return \f$|x|\f$
    */
prevariable& fabs(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  double tmp=v1.v->x;
  gradient_structure::_instance->RETURN_PTR->v->x=fabs(tmp);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), tmp >= 0.0 ? 1.0 : -1.0);

  return *gradient_structure::_instance->RETURN_PTR;
}

    /** \ingroup misc
    Smooth absolute value.
    Uses thrid order polynomial to interpolate between += 0.001.
    Derivatives correct for all values of indpendent variable != 0.
    \param v1 Indpendent variable \f$x\f$
    \return \f$|x|\f$
    */
prevariable& sfabs(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  #define cutoff 0.001 //  h
  #define cutoff2 0.000001
  double a = 2./cutoff; // 2.0/h
  double b = 1./cutoff2; // 1.0/(h*h)

  double tmp1=v1.v->x;
  double tmp=::fabs(tmp1);

  if (tmp > cutoff)
  {
    gradient_structure::_instance->RETURN_PTR->v->x=tmp;
    if (tmp1 >=0)
    {
      gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
        &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), 1);
    }
    else
    {
      gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
        &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), -1);
    }
  }
  else
  {
    double t2 = tmp * tmp;
    if (tmp1 >=0)
    {
      gradient_structure::_instance->RETURN_PTR->v->x=t2*(a-b*tmp1);
      gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
        &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), tmp*(2*a-3*b*tmp1));
    }
    else
    {
      gradient_structure::_instance->RETURN_PTR->v->x=t2*(a+b*tmp1);
      gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
        &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), tmp1*(2*a+3*b*tmp1));
    }
  }
  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& cos(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x=::cos(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), -::sin(v1.v->x));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& log(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x=::log(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), 1./(v1.v->x));

  return *gradient_structure::_instance->RETURN_PTR;
}

/**
 * Description not yet available.
 * \param
 */
prevariable& log10(const prevariable& v1)
{
  if (++gradient_structure::_instance->RETURN_PTR > gradient_structure::_instance->MAX_RETURN) 
    gradient_structure::_instance->RETURN_PTR = gradient_structure::_instance->MIN_RETURN;

  gradient_structure::_instance->RETURN_PTR->v->x=::log10(v1.v->x);
  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation,
    &(gradient_structure::_instance->RETURN_PTR->v->x), &(v1.v->x), 1./(v1.v->x)/2.3025851);

  return *gradient_structure::_instance->RETURN_PTR;
}

void DF_first_diference(void);

/**
Returns a dvector containing the differences of an x(i) and  x(i + 1) for i = 1 to x.indexmax() - 1.

\param x input.
*/
dvar_vector first_difference(const dvar_vector& x)
{
  if (x.size() <= 1)
  {
    cerr << "Error -- vector size too small"
             " in first_difference(const dvar_vector&)" << endl;
    ad_exit(1);
  }

  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;

  gs->RETURN_ARRAYS_INCREMENT();
  int mmin=x.indexmin();
  int mmax=x.indexmax()-1;
  dvar_vector tmp(mmin,mmax);
  for (int i=mmin; i<=mmax; i++)
  {
    tmp.elem_value(i)=x.elem_value(i+1)-x.elem_value(i);
  }
  save_identifier_string("CE4");
  fp->save_dvar_vector_position(x);
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("CE1");
  gs->GRAD_STACK1->set_gradient_stack(DF_first_diference);
  gs->RETURN_ARRAYS_DECREMENT();
  return(tmp);
}

/**
 * Description not yet available.
 * \param
 */
void DF_first_diference(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("CE1");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvar_vector_position x_pos=fp->restore_dvar_vector_position();
  verify_identifier_string("CE4");
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvector dfx(x_pos.indexmin(),x_pos.indexmax());
  dfx.initialize();
  for (int i=dfx.indexmax()-1; i>=dfx.indexmin(); i--)
  {
    // tmp.elem_value(i)=x.elem_value(i+1)-x.elem_value(i);
       dfx.elem(i+1)+=dftmp.elem(i);
       dfx.elem(i)-=dftmp.elem(i);
  }
  dfx.save_dvector_derivatives(x_pos);
}
#if defined(__TURBOC__)
  #pragma hdrstop
  #include <alloc.h>
#endif

#include <stdlib.h>

#ifdef DEBUG
  #include <cassert>
  #include <climits>
#endif

/**
 * Description not yet available.
 * \param
 */
dvar_vector& dvar_vector::shift(int min)
{
  va += indexmin()-min;
  index_max=index_max-index_min+min;
  index_min=min;
  shape->shift(min);
  return *this;
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector::dvar_vector(const independent_variables& t)
{
  int min = t.indexmin();
  int max = t.indexmax();
  allocate(min, max);
  if (va)
  {
    double_and_int* pva = va + min;
    double* pt = t.get_v() + min;
    for (int i = min; i <= max; ++i)
    {
      pva->x = *pt;
      ++pt;
      ++pva;
    }
    make_indvar_list(*this);
  }
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector::dvar_vector(const dvector& t): va(nullptr)
{
  if (!t)
  {
    allocate();
  }
  else
  {
    int min = t.indexmin();
    int max = t.indexmax();
    allocate(min, max);
    initialize();
    double_and_int* pva = va + min;
    double* pt = t.get_v() + min;
    for (int i = min; i <= max; ++i)
    {
      va[i].x=(t.v)[i];
      pva->x = *pt;
      ++pt;
      ++pva;
    }
  }
}


//#ifdef __BORLANDC__
 //prevariable dvar_vector::elem(int i) { return (va+i); }
//#endif

/**
 * Description not yet available.
 * \param
 */
dvar_vector::dvar_vector(unsigned int sz, double* x)
{
#ifdef DEBUG
  assert(sz > 0 && sz <= INT_MAX);
#endif
  allocate(0, (int)(sz - 1));
  for (unsigned int i = 0; i < sz; i++)
  {
    va[i].x = x[i];
  }
}

/**
 * Description not yet available.
 * \param
 */
 dvar_vector::dvar_vector(int ncl,int nch)
 {
   if (ncl>nch)
     allocate();
   else
   {
     va=NULL;
     allocate(ncl,nch);
   }
   #ifdef SAFE_INITIALIZE
     initialize();
   #endif

   #ifdef DIAG
     cout << " Allocating dvar_vector with ptr_address\n  "
         << &va << "  pointing at  " << (va+indexmin()) << "\n";
   #endif
 }

/*
 dvar_vector::dvar_vector(const ad_integer& ncl,const ad_integer& nch)
 {
   allocate(ncl,nch);
   #ifdef SAFE_INITIALIZE
     initialize();
   #endif

   #ifdef DIAG
     cout << " Allocating dvar_vector with ptr_address\n  "
         << &va << "  pointing at  " << (va+indexmin()) << "\n";
   #endif
 }
 */

/**
Default constructor
*/
dvar_vector::dvar_vector()
{
  allocate();
}

/**
 * Description not yet available.
 * \param
 */
void make_indvar_list(const dvar_vector& t)
{
  gradient_structure::_instance->make_indvar_list(t);
}
void gradient_structure::make_indvar_list(const dvar_vector& t)
{
  int min = t.indexmin();
  int max = t.indexmax();
  unsigned int size = (unsigned int)(max - min + 1);
  if (size > gradient_structure::MAX_NVAR_OFFSET)
  {
    printf("Current maximum number of independent variables is %d\n",
      gradient_structure::MAX_NVAR_OFFSET);
    printf("  You need to increase the global variable "
      "MAX_NVAR_OFFSET to %d\n", size);
    printf("  This can be done by putting the line\n"
      "    gradient_structure::set_MAX_NVAR_OFFSET(%d);\n", size);
    printf("  before the declaration of the gradient_structure object.\n"
      " or the command line option -mno %d\n", size);
    /*
    cerr << "Current maximum number of independent variables is "
         << gradient_structure::MAX_NVAR_OFFSET << "\n"
         <<  "  You need to increase the global variable MAX_NVAR_OFFSET to "
         << size << "\n"
         << "  This can be done by putting the line\n"
         << "    'gradient_structure::set_MAX_NVAR_OFFSET("
         << size << ");'\n"
         << "  before the declaration of the gradient_structure object.\n"
         << " or use the -mno 1149 command line option in AD Model Builder\n";
    */
    ad_exit(1);
  }

  double_and_int* pt = t.va + min;
  for (int i = min; i <= max; ++i)
  {
    unsigned int tmp = (unsigned int)(i - min);
    INDVAR_LIST->put_address(tmp, &(pt->x));
    ++pt;
  }
  NVAR = size;
}

/**
 * Description not yet available.
 * \param
 */
void copy_status(const ostream& _s, [[maybe_unused]] const dvar_vector& v)
   {
     ostream& s= (ostream&) _s;
     s << " copy_flag ";
     s <<"\n";
   }

/**
Does not allocate, but initializes dvar_vector to empty.
*/
void dvar_vector::allocate()
{
  va = NULL;
  link_ptr = NULL;
  shape = NULL;
  index_min = 0;
  index_max = -1;
}
/**
Allocate dvar_vector using indexes from v1.
*/
void dvar_vector::allocate(const dvector& v1)
{
  allocate(v1.indexmin(), v1.indexmax());
}
/**
Allocate dvar_vector using indexes from v1.
*/
void dvar_vector::allocate(const dvar_vector& v1)
{
  allocate(v1.indexmin(), v1.indexmax());
}

/**
 * Description not yet available.
 * \param
 */
void dvar_vector::allocatec(const dvar_vector& t)
   {
     if (!(*this))
     {
       if (t.shape)
       {
         shape=t.shape;
         (shape->ncopies)++;
       }
       else
       {
         //cerr << "Making a copy of an unallocated dvar_vector"<<endl;
       }
       link_ptr=t.link_ptr;
       index_min=t.index_min;
       index_max=t.index_max;
       va = t.va;
     }
     else
     {
       cerr << "Trying to alocate to an already allocated dvar_vector" << endl;
     }
   }

/**
Allocate dvar_vector with indexmin = ncl and indexmax = nch.
*/
void dvar_vector::allocate(int ncl, int nch)
{
  if (ncl > nch)
  {
    allocate();
  }
  else
  {
    index_min=ncl;
    index_max=nch;
    unsigned int itemp = (unsigned int)(nch - ncl + 1);
#ifdef DEBUG
    if (itemp<=0)
    {
         cerr << "Error in dvar_vector constructor max index must be"
                 " >= minindex\n"
            << "minindex = " << ncl << " maxindex = " << nch <<endl;
         ad_exit(1);
    }
#endif
    gradient_structure* gs = gradient_structure::_instance;
    if (!gs)
    {
      cerr << "Error: instance of gradient_structure is a nullptr.\n";
      ad_exit(1);
    }
    if ((va = gs->ARR_LIST1->arr_new(itemp)) == 0)
    {
      cerr << " Error trying to allocate memory for dvar_vector\n";
      ad_exit(1);
    }
    else
    {
      if ( (shape=new vector_shapex(ncl,nch,va)) == NULL)
      {
        cerr << "Error trying to allocate memory for dvar_vector\n";
        ad_exit(1);
      }
      link_ptr=* (arr_link **) va;
      va -= indexmin();
      // if ( ((int)va) %8) cerr << "Array is not QWORD alligned" << endl;
#ifdef DIAG
      myheapcheck("Leaving dvar_vector::allocate(ncl,nch)");
#endif
    }
  }
}

/**
 * Description not yet available.
 * \param
 */
   void dvar_vector::allocate(const ad_integer& ncl,const ad_integer& nch)
   {
     allocate(int(ncl),int(nch));
   }

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
  #include <iomanip.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
  #include <iomanip.hpp>
#endif

#include <stdio.h>
#include <math.h>

void shape_check(const dvar_vector& v1, const dvar_vector& v2,
  const char *function_name);
void shape_check(const dvector& v1, const dvar_vector& v2,
  const char *function_name);
void shape_check(const dvector& v1, const dvector& v2,
  const char *function_name);
void shape_check(const dvar_vector& v1, const dvector& v2,
  const char *function_name);

/**
 * Description not yet available.
 * \param
 */
 dvar_vector sinh(const dvar_vector& v1)// ***
 {
   gradient_structure* gs = gradient_structure::_instance;
   gs->RETURN_ARRAYS_INCREMENT();

   dvar_vector tmp(v1.indexmin(),v1.indexmax());
   for (int i=v1.indexmin();i<=v1.indexmax();i++)
   {
     tmp.elem(i)=sinh(v1.elem(i));             // ***
   }
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
 dvar_vector cosh(const dvar_vector& v1)// ***
 {
   gradient_structure* gs = gradient_structure::_instance;
   gs->RETURN_ARRAYS_INCREMENT();
   dvar_vector tmp(v1.indexmin(),v1.indexmax());
   for (int i=v1.indexmin();i<=v1.indexmax();i++)
   {
     tmp.elem(i)=cosh(v1.elem(i));             // ***
   }
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
 dvar_vector tanh(const dvar_vector& v1)// ***
 {
   gradient_structure* gs = gradient_structure::_instance;
   gs->RETURN_ARRAYS_INCREMENT();
   dvar_vector tmp(v1.indexmin(),v1.indexmax());
   for (int i=v1.indexmin();i<=v1.indexmax();i++)
   {
     tmp.elem(i)=tanh(v1.elem(i));             // ***
   }
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
 dvar_vector pow(const dvar_vector& v1, const dvar_vector& v2)// ***
 {
   shape_check(v1,v2,
     "dvar_vector pow(const dvar_vector& v1,const dvar_vector& v2)");

   gradient_structure* gs = gradient_structure::_instance;
   gs->RETURN_ARRAYS_INCREMENT();
   dvar_vector tmp(v1.indexmin(),v1.indexmax());
   for (int i=v1.indexmin();i<=v1.indexmax();i++)
   {
     tmp.elem(i)=pow(v1.elem(i),v2.elem(i));             // ***
   }
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
 dvar_vector pow(const prevariable& x, const dvar_vector& v2)// ***
 {
   gradient_structure* gs = gradient_structure::_instance;
   gs->RETURN_ARRAYS_INCREMENT();
   dvar_vector tmp(v2.indexmin(),v2.indexmax());
   for (int i=v2.indexmin();i<=v2.indexmax();i++)
   {
     tmp.elem(i)=pow(x,v2.elem(i));             // ***
   }
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
 dvar_vector asin(const dvar_vector& v1)// ***
 {
   gradient_structure* gs = gradient_structure::_instance;
   gs->RETURN_ARRAYS_INCREMENT();
   dvar_vector tmp(v1.indexmin(),v1.indexmax());
   for (int i=v1.indexmin();i<=v1.indexmax();i++)
   {
     tmp.elem(i)=asin(v1.elem(i));             // ***
   }
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
 dvar_vector acos(const dvar_vector& v1)// ***
 {
   gradient_structure* gs = gradient_structure::_instance;
   gs->RETURN_ARRAYS_INCREMENT();
   dvar_vector tmp(v1.indexmin(),v1.indexmax());
   for (int i=v1.indexmin();i<=v1.indexmax();i++)
   {
     tmp.elem(i)=acos(v1.elem(i));             // ***
   }
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
 dvar_vector log10(const dvar_vector& v1)// ***
 {
   gradient_structure* gs = gradient_structure::_instance;
   gs->RETURN_ARRAYS_INCREMENT();
   dvar_vector tmp(v1.indexmin(),v1.indexmax());
   for (int i=v1.indexmin();i<=v1.indexmax();i++)
   {
     tmp.elem(i)=log10(v1.elem(i));             // ***
   }
   gs->RETURN_ARRAYS_DECREMENT();
   return(tmp);
 }

/**
 * Description not yet available.
 * \param
 */
 void shape_check(const dvar_vector& v1, const dvar_vector& v2,
   const char *function_name)
 {
   if (v1.indexmin() != v2.indexmin() || v1.indexmax() != v2.indexmax())
   {
     cerr << " Vector sizes do no match in" << function_name << "\n";
     ad_exit(1);
   }
 }

/**
 * Description not yet available.
 * \param
 */
 void shape_check(const dvector& v1, const dvar_vector& v2,
   const char *function_name)
 {
   if (v1.indexmin() != v2.indexmin() || v1.indexmax() != v2.indexmax())
   {
     cerr << " Vector sizes do no match in" << function_name << "\n";
     ad_exit(1);
   }
 }

/**
 * Description not yet available.
 * \param
 */
 void shape_check(const dvar_vector& v1, const dvector& v2,
   const char *function_name)
 {
   if (v1.indexmin() != v2.indexmin() || v1.indexmax() != v2.indexmax())
   {
     cerr << " Vector sizes do no match in" << function_name << "\n";
     ad_exit(1);
   }
 }
#include "admb_messages.h"

/**
 * Description not yet available.
 * \param
 */
dvar_vector column(const dvar_matrix& m,int j)
  {
    return extract_column(m,j);
  }

/**
 * Description not yet available.
 * \param
 */
dvar_vector row(const dvar_matrix& m,int j)
  {
    return extract_row(m,j);
  }

/**
 * Description not yet available.
 * \param
 */
dvar_vector extract_column(const dvar_matrix& m, int j)
  {
    if (j < m.colmin() || j > m.colmax())
    {
      ADMB_ARRAY_BOUNDS_ERROR("Invalid matrix column specified",
      "dvar_vector extract_column(const dvar_matrix& m,int j)",
       m.colmin(), m.colmax(), j);
    }
    dvar_vector tmp(m.rowmin(),m.rowmax());

    for (int i=m.rowmin(); i<=m.rowmax(); i++)
    {
      tmp.elem(i)=m.elem(i,j);
    }
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
dvector column_value(const dvar_matrix& m, int j)
  {
    if (j < m.colmin() || j > m.colmax())
    {
      ADMB_ARRAY_BOUNDS_ERROR("Invalid matrix column specified",
      "dvector column_value(const dvar_matrix& m,int j)",
      m.colmin(), m.colmax(), j);
    }
    dvector tmp(m.rowmin(),m.rowmax());

    for (int i=m.rowmin(); i<=m.rowmax(); i++)
    {
      tmp.elem(i)=m.elem_value(i,j);
    }
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
dvar_vector extract_row(const dvar_matrix& m, int i)
  {
    if (i < m.rowmin() || i > m.rowmax())
    {
      ADMB_ARRAY_BOUNDS_ERROR("Invalid matrix row specified",
      "dvar_vector extract_row(const dvar_matrix& m,int i)",
      m.rowmin(), m.rowmax(), i);
    }
    dvar_vector tmp(m.colmin(),m.colmax());

    for (int j=m.colmin(); j<=m.colmax(); j++)
    {
      tmp.elem(j)=m.elem(i,j);
    }
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
dvar_vector fabs(const dvar_vector& t1)
  {
     gradient_structure* gs = gradient_structure::_instance;
     gs->RETURN_ARRAYS_INCREMENT();

     int min = t1.indexmin();
     int max = t1.indexmax();

     dvar_vector tmp(min, max);
     double_and_int* ptmp = tmp.va + min;
     double_and_int* pt1 = t1.va + min;
     for (int i = min; i <= max; ++i)
     {
       ptmp->x = fabs(pt1->x);
       ++ptmp;
       ++pt1;
     }

     gs->RETURN_ARRAYS_DECREMENT();
     return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
dvector value(const dvar_vector& t1)
  {
     gradient_structure* gs = gradient_structure::_instance;
     gs->RETURN_ARRAYS_INCREMENT();

     int min = t1.indexmin();
     int max = t1.indexmax();

     dvector tmp(min, max);
     double* ptmp = tmp.get_v() + min;
     double_and_int* pt1 = t1.va + min;
     for (int i = min; i <= max; ++i)
     {
       *ptmp = pt1->x;
       ++ptmp;
       ++pt1;
     }

     gs->RETURN_ARRAYS_DECREMENT();
     return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
dvariable norm(const dvar_vector& t1)
  {
    gradient_structure* gs = gradient_structure::_instance;
    gs->RETURN_ARRAYS_INCREMENT();
    dvariable tmp;
    tmp=t1*t1;
    if (value(tmp)>0.0)
    {
     tmp=pow(tmp,.5);
    }
    gs->RETURN_ARRAYS_DECREMENT();
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
dvariable norm2(const dvar_vector& t1)
  {
    gradient_structure* gs = gradient_structure::_instance;
    gs->RETURN_ARRAYS_INCREMENT();
    dvariable tmp;
    tmp=t1*t1;
    gs->RETURN_ARRAYS_DECREMENT();
    return(tmp);
  }
dvariable sumsq(const dvar_vector& t1) {return(norm2(t1));}

/**
 * Description not yet available.
 * \param
 */
dvar_vector sfabs(const dvar_vector& t1)
  {
     gradient_structure* gs = gradient_structure::_instance;
     gs->RETURN_ARRAYS_INCREMENT();

     dvar_vector tmp(t1.indexmin(),t1.indexmax());

     for (int i=t1.indexmin(); i<=t1.indexmax(); i++)
     {
       tmp.elem(i)=sfabs(t1.elem(i));
     }
     gs->RETURN_ARRAYS_DECREMENT();
     return(tmp);
  }

/// Destructor
dvar_vector::~dvar_vector()
{
  deallocate();
}
/// Deallocate dvar_vector memory.
void dvar_vector::deallocate()
{
  if (shape)
  {
#if defined(DIAG)
     cout << " Deallocating dvar_vector with ptr_address\n  "
          << &va << "  pointing at  " << (va+indexmin()) << "\n";
#endif
    if (shape->ncopies > 0)
    {
      --(shape->ncopies);
    }
    else
    {
      va = (double_and_int*) shape->trueptr;
      *(arr_link**) va = link_ptr;
      gradient_structure* gs = gradient_structure::_instance;
      gs->ARR_LIST1->arr_free(va);
      delete shape;
    }
    allocate();
  }
#if defined(DIAG)
  else
  {
    cerr << "Warning -- Unable to deallocate an unallocated dvar_vector.\n";
  }
#endif
}
/// Copy constructor
dvar_vector::dvar_vector(const dvar_vector& other)
{
  shallow_copy(other);

#if defined(DIAG)
  cout << " Making copy for dvar_vector with ptr_address\n  "
       << &va << "  pointing at  " << (va+indexmin()) << "\n";
#endif
}
/**
Shallow copy other data structure pointers.

\param other dvar_vector
*/
void dvar_vector::shallow_copy(const dvar_vector& other)
{
  if (other.shape)
  {
    shape = other.shape;
    ++(shape->ncopies);

    index_min = other.index_min;
    index_max = other.index_max;

    link_ptr = other.link_ptr;
    va = other.va;
  }
  else
  {
#if defined(DIAG)
    cerr << "Warning -- Unable to shallow copy an unallocated dvar_vector.\n";
#endif
    allocate();
  }
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector::dvar_vector(const predvar_vector& pdv)
 {
#ifndef OPT_LIB
   if (pdv.ub<pdv.lb)
   {
     cerr << "lower index greater than upper index in dvar_vector::"
       " dvar-vector(const predvar_vector&) " << endl;
     ad_exit (1);
   }
   if ((pdv.lb<pdv.p->indexmin()) || (pdv.lb>pdv.p->indexmax()))
   {
     cerr << "lower index out of bounds in dvar_vector::"
       " operator(int lb,int ub) " << endl;
     ad_exit (1);
   }

   if ((pdv.ub<pdv.p->indexmin()) || (pdv.ub>pdv.p->indexmax()))
   {
     cerr << " upper index out of bounds in dvar_vector::"
       " operator(int lb,int ub) " << endl;
     ad_exit (1);
   }
#endif
   index_min=pdv.lb;
   index_max=pdv.ub;
   shape=pdv.p->shape;
   link_ptr=pdv.p->link_ptr;
   (shape->ncopies)++;
   va = pdv.p->va;
#if defined(DIAG)
     cout << " Making copy for dvar_vector with ptr_address\n  "
           << &va << "  pointing at  " << (va+indexmin()) << "\n";
#endif
 }

/*
dvar_vector::dvar_vector(const dvar_vector& t, int lb, int ub)
 {
#ifndef OPT_LIB
   if (ub<lb)
   {
     cerr << "lower index greater than upper index in dvar_vector::"
       " operator(int lb,int ub) " << endl;
     ad_exit (1);
   }
   if ((lb<t.indexmin()) || (lb>t.indexmax()))
   {
     cerr << "lower index out of bounds in dvar_vector::"
       " operator(int lb,int ub) " << endl;
     ad_exit (1);
   }

   if ((ub<t.indexmin()) || (ub>t.indexmax()))
   {
     cerr << " upper index out of bounds in dvar_vector::"
       " operator(int lb,int ub) " << endl;
     ad_exit (1);
   }
#endif

   index_min=lb;
   index_max=ub;
   shape=t.shape;
   link_ptr=t.link_ptr;
   (shape->ncopies)++;
   va = t.va;
#if defined(DIAG)
     cout << " Making copy for dvar_vector with ptr_address\n  "
           << &va << "  pointing at  " << (va+indexmin()) << "\n";
#endif
 }
*/


/**
 * Description not yet available.
 * \param
 */
void dvar_vector::fill_multinomial(const random_number_generator& rng,
  const dvector& p)
{
  dvector tmp(indexmin(),indexmax());
  tmp.fill_multinomial(rng,p);
  *(this)=tmp;
}

/**
Returns true if ivector is allocated, otherwise false.

\param ivec ivector
*/
int allocated(const ivector& ivec)
{
  return !(!(ivec));
}
/**
Returns true if lvector is allocated, otherwise false.

\param lvec lvector
*/
int allocated(const lvector& lvec)
{
  return !(!(lvec));
}
/**
Returns true if lvector is allocated, otherwise false.

\param lvec lvector
*/
int allocated(const dvector& dvec)
{
  return !(!(dvec));
}
/**
Returns true if variables is allocated, otherwise false.

\param variables dvar_vector
*/
int allocated(const dvar_vector& variables)
{
  return !(!(variables));
}
/**
Returns true if imat is allocated, otherwise false.

\param imat imatrix
*/
int allocated(const imatrix& imat)
{
  return !(!(imat));
}
/**
Returns true if dmat is allocated, otherwise false.

\param dmat dmatrix
*/
int allocated(const dmatrix& dmat)
{
  return !(!(dmat));
}
/**
Returns true if vmat is allocated, otherwise false.

\param vmat dvar_matrix
*/
int allocated(const dvar_matrix& vmat)
{
  return !(!(vmat));
}
/**
Returns true if iarr3 is allocated, otherwise false.

\param iarr3 i3_array
*/
int allocated(const i3_array& iarr3)
{
  return !(!(iarr3));
}
/**
Returns true if arr3 is allocated, otherwise false.

\param arr3 d3_array
*/
int allocated(const d3_array& arr3)
{
  return !(!(arr3));
}
/**
Returns true if varr3 is allocated, otherwise false.

\param varr3 dvar3_array
*/
int allocated(const dvar3_array& varr3)
{
  return !(!(varr3));
}
/**
Returns true if iarr4 is allocated, otherwise false.

\param iarr4 i4_array
*/
int allocated(const i4_array& iarr4)
{
  return !(!(iarr4));
}
/**
Returns true if arr4 is allocated, otherwise false.

\param arr4 d4_array
*/
int allocated(const d4_array& arr4)
{
  return !(!(arr4));
}
/**
Returns true if varr4 is allocated, otherwise false.

\param varr4 dvar4_array
*/
int allocated(const dvar4_array& varr4)
{
  return !(!(varr4));
}
/**
Returns true if arr5 is allocated, otherwise false.

\param arr5 d5_array
*/
int allocated(const d5_array& arr5)
{
  return !(!(arr5));
}
/**
Returns true if iarr5 is allocated, otherwise false.

\param iarr5 i5_array
*/
int allocated(const i5_array& iarr5)
{
  return !(!(iarr5));
}
/**
Returns true if varr5 is allocated, otherwise false.

\param varr5 dvar5_array
*/
int allocated(const dvar5_array& varr5)
{
  return !(!(varr5));
}
/**
Returns true if arr6 is allocated, otherwise false.

\param arr6 d6_array
*/
int allocated(const d6_array& arr6)
{
  return !(!(arr6));
}
/**
Returns true if varr6 is allocated, otherwise false.

\param varr6 dvar6_array
*/
int allocated(const dvar6_array& varr6)
{
  return !(!(varr6));
}
/**
Returns true if arr7 is allocated, otherwise false.

\param arr7 d7_array
*/
int allocated(const d7_array& arr7)
{
  return !(!(arr7));
}
/**
Returns true if varr7 is allocated, otherwise false.

\param varr6 dvar7_array
*/
int allocated(const dvar7_array& varr7)
{
  return !(!(varr7));
}

/**
Returns vector of signs from variables.
-1 for negative number and zero, 1 for positive.

\param variables dvar_vector
*/
ivector sgn(const dvar_vector& variables)
{
  int mmin = variables.indexmin();
  int mmax = variables.indexmax();
  ivector signs(mmin,mmax);
  for (int i = mmin; i <= mmax; ++i)
  {
    signs(i) = variables(i) > 0.0 ? 1 : -1;
  }
  return signs;
}

 void DF_unary_diff(void);

/**
 * Description not yet available.
 * \param
 */
  dvar_vector dvar_vector::operator- (void)
  {
    gradient_structure* gs = gradient_structure::_instance;
    gs->RETURN_ARRAYS_INCREMENT();

    int mmin=indexmin();
    int mmax=indexmax();
    dvar_vector tmp(mmin,mmax);
    save_identifier_string("ec");
    for (int i=mmin; i<=mmax; i++)
    {
      tmp.elem_value(i)=-elem_value(i);
    }
    DF_FILE* fp = gradient_structure::fp;
    fp->save_dvar_vector_position(tmp);
    fp->save_dvar_vector_position(*this);
    save_identifier_string("d");
    gradient_structure::GRAD_STACK1->set_gradient_stack(DF_unary_diff);
    gs->RETURN_ARRAYS_DECREMENT();
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_unary_diff(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("d");
    dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
    dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
    dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
    dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
    verify_identifier_string("ec");
    //double xinv=1./x;
    for (int i=t1_pos.indexmax(); i>=t1_pos.indexmin(); i--)
    {
       // tmp.elem_value(i)=t1.elem_value(i)-value(x);
      //tmp.elem_value(i)=value(x)*t1.elem_value(i)/value(x);
      dft1(i)=-dftmp(i);
    }
    dft1.save_dvector_derivatives(t1_pos);
 }

/**
 * Description not yet available.
 * \param
 */
dvar_vector& dvar_vector::operator*=(const double x)
  {
    for (int i=indexmin(); i<=indexmax(); i++)
    {
      elem(i)*=x;
    }
    return(*this);
  }

/**
 * Description not yet available.
 * \param
 */
dvar_vector& dvar_vector::operator*=(const prevariable& x)
  {
    for (int i=indexmin(); i<=indexmax(); i++)
    {
      elem(i)*=x;
    }
    return(*this);
  }

  void DF_ccv_dble_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const dvector& t1, const prevariable& x)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = t1.indexmin();
  int max = t1.indexmax();
  dvar_vector tmp(min, max);
  save_identifier_string("xc");
  //x.save_prevariable_value();
  fp->save_prevariable_position(x);
  double_and_int* ptmp = tmp.va + min;
  double* pt1 = t1.get_v() + min;
  double value_x = value(x);
  for (int i = min; i <= max; ++i)
  {
    ptmp->x = *pt1 * value_x;
    ++ptmp;
    ++pt1;
  }
  fp->save_dvector_value(t1);
  fp->save_dvar_vector_position(tmp);
  fp->save_dvector_position(t1);
  save_identifier_string("Da");
  gs->RETURN_ARRAYS_DECREMENT();
  gs->GRAD_STACK1->set_gradient_stack(DF_ccv_dble_prod);
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const prevariable& x, const dvector& t1)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = t1.indexmin();
  int max = t1.indexmax();
  dvar_vector tmp(min, max);
  save_identifier_string("xc");
  //x.save_prevariable_value();
  fp->save_prevariable_position(x);
  double_and_int* ptmp = tmp.va + min;
  double* pt1 = t1.get_v() + min;
  double value_x = value(x);
  for (int i = min; i <= max; ++i)
  {
    ptmp->x = value_x * (*pt1);
    ++ptmp;
    ++pt1;
  }
  fp->save_dvector_value(t1);
  fp->save_dvar_vector_position(tmp);
  fp->save_dvector_position(t1);
  save_identifier_string("Da");
  gs->RETURN_ARRAYS_DECREMENT();
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_ccv_dble_prod);
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_ccv_dble_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("Da");
  dvector_position t1_pos=fp->restore_dvector_position();
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector t1=restore_dvar_vector_value(tmp_pos);
  prevariable_position xpos=fp->restore_prevariable_position();
  //double x=restore_prevariable_value();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  //dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
  verify_identifier_string("xc");
  double dfx=0.;
  int min = t1_pos.indexmin();
  int max = t1_pos.indexmax();
  double* pdftmp = dftmp.get_v() + max;
  double* pt1 = t1.get_v() + max;
  for (int i = max; i >= min; --i)
  {
    //tmp.elem_value(i)=value(x)*t1.elem_value(i)*value(x);
    dfx += *pdftmp * (*pt1);
    --pdftmp;
    --pt1;
    //dft1(i)=dftmp(i)*x;
  }
  save_double_derivative(dfx,xpos);
  //dft1.save_dvector_derivatives(t1_pos);
}

  void DF_v_xdble_diff(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator-(const dvector& t1, const prevariable& x)
  {
    gradient_structure* gs = gradient_structure::_instance;
    DF_FILE* fp = gradient_structure::fp;
    gs->RETURN_ARRAYS_INCREMENT();

    int min = t1.indexmin();
    int max = t1.indexmax();
    dvar_vector tmp(min, max);
    save_identifier_string("zcb");
    fp->save_prevariable_position(x);

    double_and_int* ptmp = tmp.va + min;
    double* pt1 = t1.get_v() + min;
    double value_x = value(x);
    for (int i = min; i <= max; ++i)
    {
      //tmp.elem_value(i)=t1.elem(i)-value(x);
      ptmp->x = *pt1 - value_x;
      ++ptmp;
      ++pt1;
    }
    fp->save_dvar_vector_position(tmp);
    save_identifier_string("ddu");
    gradient_structure::GRAD_STACK1->set_gradient_stack(DF_v_xdble_diff);
    gs->RETURN_ARRAYS_DECREMENT();
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_v_xdble_diff(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("ddu");
    dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
    prevariable_position xpos=fp->restore_prevariable_position();
    dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
    verify_identifier_string("zcb");
    //double xinv=1./x;
    int min = tmp_pos.indexmin();
    int max = tmp_pos.indexmax();
    double dfx = 0.0;
    double* pdftmp = dftmp.get_v() + max;
    for (int i = max; i >= min; --i)
    {
      // tmp.elem_value(i)=t1.elem(i)-value(x);
      //dfx -= dftmp(i);
      dfx -= *pdftmp;
      --pdftmp;
    }
    save_double_derivative(dfx,xpos);
 }

void DF_dv_double_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const dvar_vector& t1, const double x)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = t1.indexmin();
  int max = t1.indexmax();
  dvar_vector tmp(min, max);
  save_identifier_string("ccbb");
  fp->save_double_value(x);
  double_and_int* ptmpi = tmp.va + min;
  double_and_int* pt1i = t1.va + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = pt1i->x * x;

    ++pt1i;
    ++ptmpi;
  }

  fp->save_dvar_vector_position(tmp);
  fp->save_dvar_vector_position(t1);
  save_identifier_string("DDaa");
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dv_double_prod);
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dv_double_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("DDaa");
  dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  double x=fp->restore_double_value();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);

  int min = t1_pos.indexmin();
  int max = t1_pos.indexmax();
  dvector dft1(min, max);
  verify_identifier_string("ccbb");
  double* pdft1i = dft1.get_v() + max;
  double* pdftmpi = dftmp.get_v() + max;
  for (int i = max; i >= min; --i)
  {
    //tmp.elem_value(i)=value(x)*t1.elem_value(i)*x;
    *pdft1i = *pdftmpi * x;

    --pdft1i;
    --pdftmpi;
  }
  dft1.save_dvector_derivatives(t1_pos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const double x, const dvar_vector& t1)
{
  return t1 * x;
}
/*
    dvar_vector dvar_vector::operator()(int low,int high)
    {
      if (low>high)
      {
        cerr << " low index > high index in"
                 " dvar_vector::operator()(int low,int high)"  << endl;
        ad_exit(1);
      }
      if (low<indexmin())
      {
        cerr << "lower index out of bounds in"
                " dvar_vector::operator()(int low,int high)" << endl ;
        ad_exit(1);
      }
      if (high>indexmax())
      {
        cerr << "upper index out of bounds in"
                " dvar_vector::operator()(int low,int high)" << endl;
        ad_exit(1);
      }
      dvar_vector tmp(low,high);
      for (int i=low;i<=high;i++)
      {
        tmp(i)=(*this)(i);
      }
      return tmp;
    }
*/

void DF_dvexp(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector mfexp(const dvar_vector& v1, const double d)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    if (v1.elem_value(i)<d)
    {
      vtmp.elem_value(i)=exp(v1.elem_value(i));
    }
    else
    {
      vtmp.elem_value(i)=exp(d);
      cout << "In mfexp d =" << d << " mfexp(x) = " << vtmp(i)  << endl;
    }
  }

  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddd");
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_value(vtmp);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("hee");
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dvexp);
  return vtmp;
}

void DF_dvmfexp(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector mfexp(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  int mmin=v1.indexmin();
  int mmax=v1.indexmax();
  dvar_vector vtmp(mmin,mmax);

  double_and_int* pvtmpi = vtmp.va + mmin;
  double_and_int* pv1i = v1.va + mmin;

  for (int i=mmin;i<=mmax;i++)
  {
    double v1i = pv1i->x;
    if (v1i < 60.0)
    {
      pvtmpi->x = exp(v1i);
    }
    else
    {
      double exp60 = exp(60.0);
      double x = v1i - 60.0;
      pvtmpi->x = exp60 * (1.0 + 2.0 * x)/(1.0 + x);
    }

    ++pvtmpi;
    ++pv1i;
  }

  DF_FILE* fp = gradient_structure::fp;

  save_identifier_string("ddt");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_value(vtmp);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("see");
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dvmfexp);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dvmfexp(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("see");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvector vtmp=restore_dvar_vector_value(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ddt");
  int min = dfvtmp.indexmin();
  int max = dfvtmp.indexmax();
  dvector dfv1(min, max);

  double* pdfv1i = dfv1.get_v() + min;
  double* pdfvtmpi = dfvtmp.get_v() + min;
  double* pvtmpi = vtmp.get_v() + min;
  double* pv1i = v1.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    //vtmp.elem(i)=mfexp(value(v1.elem(i))));
    if (*pv1i < 60.0)
    {
      *pdfv1i = *pdfvtmpi * *pvtmpi;
    }
    else
    {
      double exp60 = exp(60.0);
      double b = *pv1i - 60.0;
      *pdfv1i = *pdfvtmpi * exp60 * std::pow(1.0 + b, -2.0);
    }

    ++pdfv1i;
    ++pdfvtmpi;
    ++pvtmpi;
    ++pv1i;
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

#include <math.h>

/**
 * Description not yet available.
 * \param
 */
dvariable var(const dvar_vector& v)
  {
    dvariable tmp;
    gradient_structure* gs = gradient_structure::_instance;
    gs->RETURN_ARRAYS_INCREMENT();
    tmp=norm(v)/sqrt(double(v.size()));
    dvariable tmp1;
    tmp1=mean(v);
    gs->RETURN_ARRAYS_DECREMENT();
    return(tmp*tmp-tmp1*tmp1);
  }

/**
 * Description not yet available.
 * \param
 */
dvariable std_dev(const dvar_vector& v)
  {
    dvariable tmp;
    gradient_structure* gs = gradient_structure::_instance;
    gs->RETURN_ARRAYS_INCREMENT();
    tmp=norm(v)/sqrt(double(v.size()));
    dvariable tmp1;
    tmp1=mean(v);
    gs->RETURN_ARRAYS_DECREMENT();
    return(sqrt(tmp*tmp-tmp1*tmp1));
  }

/**
Compute mean of v.
*/
dvariable mean(const dvar_vector& v)
{
  dvariable tmp = 0.0;
  if (allocated(v))
  {
    gradient_structure* gs = gradient_structure::_instance;
    gs->RETURN_ARRAYS_INCREMENT();
    tmp = sum(v) / double(v.size());
    gs->RETURN_ARRAYS_DECREMENT();
  }
  return tmp;
}

  void DF_cdble_dv_diveq(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector& dvar_vector::operator/=(const double x)
  {
    gradient_structure* gs = gradient_structure::_instance;
    gs->RETURN_ARRAYS_INCREMENT();
    save_identifier_string("wctf");
    double xinv = 1.0 / x;
    int min = index_min;
    int max = index_max;
    double_and_int* pva = va + min;
    for (int i = min; i <= max; ++i)
    {
      pva->x *=xinv;
      ++pva;
    }
    DF_FILE* fp = gradient_structure::fp;
    fp->save_dvar_vector_position(*this);
    fp->save_double_value(x);
    save_identifier_string("cmtu");
    gs->GRAD_STACK1->set_gradient_stack(DF_cdble_dv_diveq);
    gs->RETURN_ARRAYS_DECREMENT();
    return(*this);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_cdble_dv_diveq(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("cmtu");
    double x=fp->restore_double_value();
    dvar_vector_position this_pos=fp->restore_dvar_vector_position();
    dvector dfthis=restore_dvar_vector_derivatives(this_pos);
    verify_identifier_string("wctf");
    double xinv=1./x;
    int max = dfthis.indexmax();
    int min = dfthis.indexmin();
    double* pdfthis = dfthis.get_v() + max;
    for (int i = max; i >= min; --i)
    {
      // elem_value(i)=elem_value(i)/x;
      //dfthis(i)*=xinv;
      *pdfthis *= xinv;
      --pdfthis;
    }
    dfthis.save_dvector_derivatives(this_pos);
 }


  void DF_vdble_dv_diveq(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector& dvar_vector::operator/=(const prevariable& x)
  {
    gradient_structure* gs = gradient_structure::_instance;
    DF_FILE* fp = gradient_structure::fp;
    gs->RETURN_ARRAYS_INCREMENT();

    double xinv = 1.0 / value(x);
    int min = index_min;
    int max = index_max;
    double_and_int* pva = va + min;
    for (int i = min; i <= max; ++i)
    {
      //elem_value(i)=elem_value(i)*xinv;
      pva->x *= xinv;
      ++pva;
    }
    save_identifier_string("wctg");
    fp->save_dvar_vector_value(*this);
    fp->save_dvar_vector_position(*this);
    fp->save_prevariable_value(x);
    fp->save_prevariable_position(x);
    save_identifier_string("cmtu");
    gs->RETURN_ARRAYS_DECREMENT();
    gradient_structure::GRAD_STACK1->set_gradient_stack(DF_vdble_dv_diveq);
    return(*this);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_vdble_dv_diveq(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("cmtu");
    prevariable_position x_pos=fp->restore_prevariable_position();
    double dfx=restore_prevariable_derivative(x_pos);
    double x=fp->restore_prevariable_value();
    dvar_vector_position this_pos=fp->restore_dvar_vector_position();
    dvector tmp=restore_dvar_vector_value(this_pos);
    dvector dfthis=restore_dvar_vector_derivatives(this_pos);
    verify_identifier_string("wctg");
    double tmp1=0.0;
    double xinv=1.0/x;
    int max = dfthis.indexmax();
    int min = dfthis.indexmin();
    double* pdfthis = dfthis.get_v() + max;
    double* ptmp = tmp.get_v() + max;
    for (int i = max; i >= min; --i)
    {
      // elem_value(i)=elem_value(i)/x;
      //tmp1+=dfthis(i)*tmp(i);
      tmp1 += *pdfthis * *ptmp;
      --pdfthis;
      --ptmp;
    }
    tmp1*=-xinv;

    pdfthis = dfthis.get_v() + max;
    for (int i = max; i >= min; --i)
    {
      // elem_value(i)=elem_value(i)/x;
      *pdfthis *= xinv;
      --pdfthis;
    }
    dfthis.save_dvector_derivatives(this_pos);
    save_double_derivative(dfx+tmp1,x_pos);
 }

/**
 * Description not yet available.
 * \param
 */
void dvar_vector::fill_multinomial(const int& seed,const dvector& p)
{
  dvector tmp(indexmin(),indexmax());
  tmp.fill_multinomial(seed,p);
  *(this)=tmp;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


void dvdv_elem_div(void);

/**
Element-wise division of v1 by v2 into a dvar_vector.

@param v1 dvar_vector of numerators
@param v2 dvar_vector of denominators
*/
dvar_vector elem_div(const dvar_vector& v1, const dvar_vector& v2)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = v1.indexmin();
  int max = v1.indexmax();
#ifndef OPT_LIB
  if (min != v2.indexmin() || max != v2.indexmax())
  {
    cerr << "Incompatible bounds in "
    "dvar_vector elem_prod(const dvar_vector& v1, const dvar_vector& v2)"
    << endl;
    ad_exit(1);
  }
#endif
  dvar_vector tmp(min, max);
  dvector tmp_inv(min, max);

  double_and_int* pv1 = v1.va + min;
  double_and_int* pv2 = v2.va + min;
  double* ptmp_inv = tmp_inv.get_v() + min;
  double_and_int* ptmp = tmp.va + min;
  for (int i = min; i <= max; ++i)
  {
    *ptmp_inv = 1.0 / pv2->x;
    ptmp->x = pv1->x * *ptmp_inv;
    ++pv2;
    ++pv1;
    ++ptmp_inv;
    ++ptmp;
  }

  // The derivative list considerations
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("bbbb");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  save_identifier_string("wwww");
  fp->save_dvector_value(tmp_inv);
  fp->save_dvector_position(tmp_inv);
  save_identifier_string("vvvv");
  fp->save_dvar_vector_position(v2);
  save_identifier_string("uuuu");
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("aaaa");
  gradient_structure::GRAD_STACK1->set_gradient_stack(dvdv_elem_div);
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}
/**
Adjoint gradient computation of elem_div(const dvar_vector&, const dvar_vector&)
*/
void dvdv_elem_div(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("aaaa");
  dvar_vector_position tmppos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmppos);
  verify_identifier_string("uuuu");
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  verify_identifier_string("vvvv");
  dvector_position tmp_divpos=fp->restore_dvector_position();
  dvector tmp_div=fp->restore_dvector_value(tmp_divpos);
  verify_identifier_string("wwww");
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector cv1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("bbbb");

  int min = cv1.indexmin();
  int max = cv1.indexmax();
  dvector dfv1(min, max);
  int min2 = tmp_div.indexmin();
  int max2 = tmp_div.indexmax();
  dvector dfv2(min2, max2);

  double* ptmp_div = tmp_div.get_v() + min;
  double* pdftmp = dftmp.get_v() + min;
  double* pcv1 = cv1.get_v() + min;
  double* pdfv1 = dfv1.get_v() + min;
  double* pdfv2 = dfv2.get_v() + min2;
  for (int i = min; i <= max; ++i)
  {
    //tmp+=cv1(i)*cv2(i);

    //double& xx=tmp_div.elem(i);
    double xx = *ptmp_div;
    //dfv1(i)=dftmp.elem(i)*xx;
    *pdfv1 = *pdftmp * xx;
    //dfv2(i)=-dftmp.elem(i)*cv1.elem(i)*xx*xx;
    *pdfv2 = -(*pdftmp) * *pcv1 * xx * xx;
    ++ptmp_div;
    ++pdftmp;
    ++pcv1;
    ++pdfv1;
    ++pdfv2;
  }
  dfv1.save_dvector_derivatives(v1pos);
  dfv2.save_dvector_derivatives(v2pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void dvcv_elem_div(void);

/**
Element-wise division of v1 by v2 into a dvar_vector.

@param v1 dvar_vector of numerators
@param v2 dvector of denominators
*/
dvar_vector elem_div(const dvar_vector& v1, const dvector& v2)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = v1.indexmin();
  int max = v1.indexmax();
#ifndef OPT_LIB
  if (min != v2.indexmin() || max != v2.indexmax())
  {
    cerr << "Incompatible bounds in "
    "dvar_vector elem_prod(const dvar_vector& v1, const dvar_vector& v2)"
    << endl;
    ad_exit(1);
  }
#endif
  dvar_vector tmp(min, max);
  dvector tmp_inv(min, max);

  double_and_int* pv1 = v1.va + min;
  double* pv2 = v2.get_v() + min;
  double* ptmp_inv = tmp_inv.get_v() + min;
  double_and_int* ptmp = tmp.va + min;
  for (int i = min; i <= max; ++i)
  {
    //tmp_inv.elem(i)=1./v2.elem(i);
    //tmp.elem_value(i)=v1.elem_value(i)*tmp_inv.elem(i);
    *ptmp_inv = 1.0 / *pv2;
    ptmp->x = pv1->x * *ptmp_inv;
    ++ptmp_inv;
    ++ptmp;
    ++pv1;
    ++pv2;
  }

  // The derivative list considerations
  save_identifier_string("bbbb");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  save_identifier_string("wwww");
  fp->save_dvector_value(tmp_inv);
  fp->save_dvector_position(tmp_inv);
  save_identifier_string("vvvv");
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("aaaa");
  gs->GRAD_STACK1->set_gradient_stack(dvcv_elem_div);
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}
/**
Adjoint gradient computation of elem_div(const dvar_vector&, const dvector&)
*/
void dvcv_elem_div(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("aaaa");
  dvar_vector_position tmppos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmppos);
  verify_identifier_string("vvvv");
  dvector_position tmp_divpos=fp->restore_dvector_position();
  dvector tmp_div=fp->restore_dvector_value(tmp_divpos);
  verify_identifier_string("wwww");
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector cv1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("bbbb");
  dvector dfv1(cv1.indexmin(),cv1.indexmax());
  for (int i=cv1.indexmin();i<=cv1.indexmax();i++)
  {
    dfv1(i)=dftmp.elem(i)*tmp_div.elem(i);
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void cvdv_elem_div(void);

/**
Element-wise division of v1 by v2 into a dvar_vector.

@param v1 dvector of numerators
@param v2 dvar_vector of denominators
*/
dvar_vector elem_div(const dvector& v1, const dvar_vector& v2)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  gs->RETURN_ARRAYS_INCREMENT();

  if (v1.indexmin()!=v2.indexmin()||v1.indexmax()!=v2.indexmax())
  {
    cerr << "Incompatible bounds in "
    "dvar_vector elem_prod(const dvar_vector& v1, const dvar_vector& v2)"
    << endl;
    ad_exit(1);
  }
  dvar_vector tmp(v1.indexmin(),v1.indexmax());
  dvector tmp_inv(v1.indexmin(),v1.indexmax());

  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    double x=1./v2.elem_value(i);
    tmp.elem_value(i)=v1.elem(i)*x;
    tmp_inv.elem(i)=-tmp.elem_value(i)*x;
  }

  // The derivative list considerations
  save_identifier_string("bbbb");
  fp->save_dvector_value(tmp_inv);
  fp->save_dvector_position(tmp_inv);
  save_identifier_string("vvvv");
  fp->save_dvar_vector_position(v2);
  save_identifier_string("uuuu");
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("aaaa");
  gs->GRAD_STACK1->set_gradient_stack(cvdv_elem_div);
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}
/**
Adjoint gradient computation of elem_div(const dvector&, const dvar_vector&)
*/
void cvdv_elem_div(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("aaaa");
  dvar_vector_position tmppos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmppos);
  verify_identifier_string("uuuu");
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  verify_identifier_string("vvvv");
  dvector_position tmp_divpos=fp->restore_dvector_position();
  dvector tmp_div=fp->restore_dvector_value(tmp_divpos);
  verify_identifier_string("bbbb");
  dvector dfv2(tmp_div.indexmin(),tmp_div.indexmax());
  for (int i=dfv2.indexmin();i<=dfv2.indexmax();i++)
  {
    //tmp+=cv1(i)*cv2(i);
    dfv2(i)=dftmp.elem(i)*tmp_div.elem(i);
  }
  dfv2.save_dvector_derivatives(v2pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


void dvdv_elem_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector elem_prod(const dvar_vector& v1, const dvar_vector& v2)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = v1.indexmin();
  int max = v1.indexmax();
#ifndef OPT_LIB
  if (min != v2.indexmin() || max != v2.indexmax())
  {
    cerr << "Incompatible bounds in "
    "dvar_vector elem_prod(const dvar_vector& v1, const dvar_vector& v2)"
    << endl;
    ad_exit(1);
  }
#endif
  dvar_vector tmp(min, max);

  double_and_int* ptmpi = tmp.va + min;
  const double_and_int* pv1i = v1.va + min;
  const double_and_int* pv2i = v2.va + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = pv1i->x * pv2i->x;
    ++ptmpi;
    ++pv1i;
    ++pv2i;
  }

  // The derivative list considerations
  save_identifier_string("b");
  DF_FILE* fp = gradient_structure::fp;
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_value(v2);
  fp->save_dvar_vector_position(v2);
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("a");
  gradient_structure::GRAD_STACK1->set_gradient_stack(dvdv_elem_prod);
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void dvdv_elem_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("a");
  dvar_vector_position tmppos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmppos);
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  dvector cv2=restore_dvar_vector_value(v2pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector cv1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("b");
  int min = cv1.indexmin();
  int max = cv2.indexmax();
  dvector dfv1(min, max);
  dvector dfv2(min, max);

  double* pdfv1i = dfv1.get_v() + min;
  double* pdfv2i = dfv2.get_v() + min;
  double* pdftmpi = dftmp.get_v() + min;
  double* pcv1i = cv1.get_v() + min;
  double* pcv2i = cv2.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    //tmp+=cv1(i)*cv2(i);
    *pdfv1i = *pdftmpi * *pcv2i;
    *pdfv2i = *pdftmpi * *pcv1i;

    ++pdfv1i;
    ++pdfv2i;
    ++pdftmpi;
    ++pcv1i;
    ++pcv2i;
  }
  dfv1.save_dvector_derivatives(v1pos);
  dfv2.save_dvector_derivatives(v2pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void cvdv_elem_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector elem_prod(const dvector& v1, const dvar_vector& v2)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = v1.indexmin();
  int max = v1.indexmax();
#ifndef OPT_LIB
  if (min != v2.indexmin() || max != v2.indexmax())
  {
    cerr << "Incompatible bounds in dvar_vector elem_prod(const dvector&, const dvar_vector&)\n";
    ad_exit(1);
  }
#endif

  dvar_vector tmp(min, max);

  double_and_int* ptmpi = tmp.va + min;
  double* pv1i = v1.get_v() + min;
  double_and_int* pv2i = v2.va + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = *pv1i * pv2i->x;

    ++ptmpi;
    ++pv1i;
    ++pv2i;
  }

  // The derivative list considerations
  save_identifier_string("b");
  fp->save_dvector_value(v1);
  fp->save_dvector_position(v1);
  fp->save_dvar_vector_position(v2);
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("a");
  gs->GRAD_STACK1->set_gradient_stack(cvdv_elem_prod);
  gs->RETURN_ARRAYS_DECREMENT();

  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void cvdv_elem_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("a");
  dvar_vector_position tmppos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmppos);
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  dvector_position v1pos=fp->restore_dvector_position();
  dvector cv1=fp->restore_dvector_value(v1pos);
  verify_identifier_string("b");

  int min = cv1.indexmin();
  int max = cv1.indexmax();
  dvector dfv2(min, max);

  double* pdfv2i = dfv2.get_v() + min;
  double* pdftmpi = dftmp.get_v() + min;
  double* pcv1i = cv1.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    //tmp+=cv1(i)*cv2(i);
    *pdfv2i = *pdftmpi * *pcv1i;

    ++pdfv2i;
    ++pdftmpi;
    ++pcv1i;
  }
  dfv2.save_dvector_derivatives(v2pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void dvcv_elem_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector elem_prod(const dvar_vector& v1, const dvector& v2)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = v1.indexmin();
  int max = v1.indexmax();
#ifndef OPT_LIB
  if (min != v2.indexmin() || max != v2.indexmax())
  {
    cerr << "Incompatible bounds in dvar_vector elem_prod(const dvar_vector&, const dvector&)\n";
    ad_exit(1);
  }
#endif
  dvar_vector tmp(min, max);

  double_and_int* ptmpi = tmp.va + min;
  double_and_int* pv1i = v1.va + min;
  double* pv2i = v2.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = pv1i->x * *pv2i;

    ++ptmpi;
    ++pv1i;
    ++pv2i;
  }

  // The derivative list considerations
  save_identifier_string("b");
  fp->save_dvar_vector_position(v1);
  fp->save_dvector_value(v2);
  fp->save_dvector_position(v2);
  fp->save_dvar_vector_position(tmp);
  save_identifier_string("a");
  gs->GRAD_STACK1->set_gradient_stack(dvcv_elem_prod);
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void dvcv_elem_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("a");
  dvar_vector_position tmppos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmppos);
  dvector_position v2pos=fp->restore_dvector_position();
  dvector cv2=fp->restore_dvector_value(v2pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  verify_identifier_string("b");

  int min = cv2.indexmin();
  int max = cv2.indexmax();
  dvector dfv1(min, max);
  double* pdfv1i = dfv1.get_v() + min;
  double* pdftmpi = dftmp.get_v() + min;
  double* pcv2i = cv2.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    //tmp+=cv1(i)*cv2(i);
    *pdfv1i = *pdftmpi * *pcv2i;

    ++pdfv1i;
    ++pdftmpi;
    ++pcv2i;
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvsquare(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector square(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  int min = v1.indexmin();
  int max = v1.indexmax();

  dvar_vector vtmp(min, max);

  double_and_int* pvtmp = vtmp.va + min;
  double_and_int* pv1 = v1.va + min;
  for (int i = min; i <= max; ++i)
  {
    //double x = v1.elem_value(i);
    double x = pv1->x;
    //vtmp.elem_value(i) = x * x;
    pvtmp->x = x * x;

    ++pv1;
    ++pvtmp;
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("sddd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eee");
  GRAD_STACK1->set_gradient_stack(DF_dvsquare);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dvsquare(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("eee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("sddd");

  int min = dfvtmp.indexmin();
  int max = dfvtmp.indexmax();
  dvector dfv1(min, max);

  double* pv1 = v1.get_v() + min;
  double* pdfv1 = dfv1.get_v() + min;
  double* pdfvtmp = dfvtmp.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    //double x=v1.elem(i);
    double x = *pv1;
    //dfv1(i)=dfvtmp(i)*2*x;
    *pdfv1 = *pdfvtmp * 2.0 * x;
    ++pv1;
    ++pdfvtmp;
    ++pdfv1;
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}


void DF_dvcube(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector cube(const dvar_vector& v1)
{
  //dvector cv1=value(v1);

  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    double x=v1.elem_value(i);
    vtmp.elem_value(i)=x*x*x;
  }

  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("sssd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("tee");
  gs->GRAD_STACK1->set_gradient_stack(DF_dvcube);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dvcube(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("tee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("sssd");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    double x=v1.elem(i);
    dfv1(i)=dfvtmp(i)*3*x*x;
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvfourth(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector fourth(const dvar_vector& v1)
{
  //dvector cv1=value(v1);

  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    double x=v1.elem_value(i);
    double x2=x*x;
    vtmp.elem_value(i)=x2*x2;
  }

  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ssf");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("gee");
  gs->GRAD_STACK1->set_gradient_stack(DF_dvfourth);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dvfourth(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("gee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ssf");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    double x=v1.elem(i);
    dfv1(i)=dfvtmp(i)*4*x*x*x;
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

 void DF_cdble_dv_div(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator/(const double x, const dvar_vector& t1)
  {
    gradient_structure* gs = gradient_structure::_instance;
    DF_FILE* fp = gradient_structure::fp;
    gs->RETURN_ARRAYS_INCREMENT();

    dvar_vector tmp(t1.indexmin(),t1.indexmax());
    save_identifier_string("cffb");
    fp->save_double_value(x);
    for (int i=t1.indexmin(); i<=t1.indexmax(); i++)
    {
      tmp.elem_value(i)=x/t1.elem_value(i);
    }
    fp->save_dvar_vector_value(t1);
    fp->save_dvar_vector_position(tmp);
    fp->save_dvar_vector_position(t1);
    save_identifier_string("dffa");
    gs->RETURN_ARRAYS_DECREMENT();
    gradient_structure::GRAD_STACK1->set_gradient_stack(DF_cdble_dv_div);
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_cdble_dv_div(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("dffa");
    dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
    dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
    dvector t1=restore_dvar_vector_value(t1_pos);
    double x=fp->restore_double_value();
    dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
    dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
    verify_identifier_string("cffb");
    for (int i=t1_pos.indexmax(); i>=t1_pos.indexmin(); i--)
    {
      //tmp.elem_value(i)=value(x)/t1.elem_value(i);
      double t1inv=1./t1.elem(i);
      dft1(i)=-dftmp(i)*x*t1inv*t1inv;
    }
    dft1.save_dvector_derivatives(t1_pos);
 }

 void DF_dble_dv_div(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator/(const prevariable& x, const dvar_vector& t1)
  {
    gradient_structure* gs = gradient_structure::_instance;
    DF_FILE* fp = gradient_structure::fp;
    gs->RETURN_ARRAYS_INCREMENT();

    dvar_vector tmp(t1.indexmin(),t1.indexmax());
    save_identifier_string("ceeb");
    fp->save_prevariable_value(x);
    fp->save_prevariable_position(x);
    for (int i=t1.indexmin(); i<=t1.indexmax(); i++)
    {
      tmp.elem_value(i)=value(x)/t1.elem_value(i);
    }
    fp->save_dvar_vector_value(t1);
    fp->save_dvar_vector_position(tmp);
    fp->save_dvar_vector_position(t1);
    save_identifier_string("deea");
    gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dble_dv_div);
    gs->RETURN_ARRAYS_DECREMENT();
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_dble_dv_div(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("deea");
    dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
    dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
    dvector t1=restore_dvar_vector_value(t1_pos);
    prevariable_position xpos=fp->restore_prevariable_position();
    double x=fp->restore_prevariable_value();
    dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
    dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
    verify_identifier_string("ceeb");
    double dfx=0.;
    for (int i=t1_pos.indexmax(); i>=t1_pos.indexmin(); i--)
    {
      //tmp.elem_value(i)=value(x)/t1.elem_value(i);
      double t1inv=1./t1.elem(i);
      dfx+=dftmp(i)*t1inv;
      dft1(i)=-dftmp(i)*x*t1inv*t1inv;
    }
    save_double_derivative(dfx,xpos);
    dft1.save_dvector_derivatives(t1_pos);
 }

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator+(const dvar_vector& t1, const double x)
{
  return x + t1;
}

void DF_cdble_dv_add(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator+(const double x, const dvar_vector& t1)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = t1.indexmin();
  int max = t1.indexmax();
  dvar_vector tmp(min, max);
  save_identifier_string("wctf");

  double_and_int* ptmpi = tmp.va + min;
  const double_and_int* pt1i = t1.va + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = pt1i->x + x;

    ++ptmpi;
    ++pt1i;
  }
  DF_FILE* fp = gradient_structure::fp;
  fp->save_dvar_vector_position(tmp);
  fp->save_dvar_vector_position(t1);
  save_identifier_string("ddtu");
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_cdble_dv_add);
  gs->RETURN_ARRAYS_DECREMENT();

  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_cdble_dv_add(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("ddtu");
  dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);

  int min = t1_pos.indexmin();
  int max = t1_pos.indexmax();
  dvector dft1(min, max);
  verify_identifier_string("wctf");

  double* pdft1i = dft1.get_v() + max;
  double* pdftmpi = dftmp.get_v() + max;
  for (int i = max; i >= min; --i)
  {
    // tmp.elem_value(i)=x+t1.elem_value(i);
    *pdft1i = *pdftmpi;

    --pdft1i;
    --pdftmpi;
  }
  dft1.save_dvector_derivatives(t1_pos);
}

void DF_cdble_dv_diff(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator-(const double x, const dvar_vector& t1)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = t1.indexmin();
  int max = t1.indexmax();
  dvar_vector tmp(min, max);
  //save_identifier_string("ecbb");
  double_and_int* ptmpi = tmp.va + min;
  double_and_int* pt1i = t1.va + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = x - pt1i->x;
    ++ptmpi;
    ++pt1i;
  }
  DF_FILE* fp = gradient_structure::fp;
  fp->save_dvar_vector_position(tmp);
  fp->save_dvar_vector_position(t1);
  //save_identifier_string("druu");
  gs->GRAD_STACK1->set_gradient_stack(DF_cdble_dv_diff);
  gs->RETURN_ARRAYS_DECREMENT();
  return(tmp);
}

/**
 * Description not yet available.
 * \param
 */
void DF_cdble_dv_diff(void)
{
  DF_FILE* fp = gradient_structure::fp;

  //verify_identifier_string("druu");
  dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  int min = t1_pos.indexmin();
  int max = t1_pos.indexmax();
  dvector dft1(min, max);
  //verify_identifier_string("ecbb");
  //double xinv=1./x;
  double* pdft1i = dft1.get_v() + max;
  double* pdftmpi = dftmp.get_v() + max;
  for (int i = max; i >= min; --i)
  {
    // tmp.elem_value(i)=t1.elem_value(i)-value(x);
    //tmp.elem_value(i)=value(x)*t1.elem_value(i)/value(x);
    *pdft1i = -(*pdftmpi);

    --pdft1i;
    --pdftmpi;
  }
  dft1.save_dvector_derivatives(t1_pos);
}

void DF_dv_minus(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator-(const dvar_vector& t1)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = t1.indexmin();
  int max = t1.indexmax();
  dvar_vector tmp(min, max);
  //save_identifier_string("vcbb");
  const double_and_int* pt1i = t1.va + min;
  double_and_int* ptmpi = tmp.va + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = -pt1i->x;

    ++ptmpi;
    ++pt1i;
  }
  DF_FILE* fp = gradient_structure::fp;
  fp->save_dvar_vector_position(tmp);
  fp->save_dvar_vector_position(t1);
  //save_identifier_string("tduu");
  gs->RETURN_ARRAYS_DECREMENT();
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dv_minus);
  return(tmp);
}

/**
 * Description not yet available.
 * \param
 */
void DF_dv_minus(void)
{
  DF_FILE* fp = gradient_structure::fp;

  //verify_identifier_string("tduu");
  dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  int min = t1_pos.indexmin();
  int max = t1_pos.indexmax();
  dvector dft1(min, max);
  //verify_identifier_string("vcbb");
  //double xinv=1./x;
  double* pdft1i = dft1.get_v() + max;
  double* pdftmpi = dftmp.get_v() + max;
  for (int i = max; i >= min; --i)
  {
    // tmp.elem_value(i)=t1.elem_value(i)-value(x);
    //tmp.elem_value(i)=value(x)*t1.elem_value(i)/value(x);
    *pdft1i = -(*pdftmpi);
    --pdft1i;
    --pdftmpi;
  }
  dft1.save_dvector_derivatives(t1_pos);
}

void DF_dv_cdble_diff(void);

/**
Subtracts x from each element of t1 into a dvar_vector.

@param t1 dvar_vector
@param x double
@returns dvar_vector result
*/
dvar_vector operator-(const dvar_vector& t1, const double x)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  dvar_vector tmp(t1.indexmin(),t1.indexmax());
  save_identifier_string("ucbb");
  for (int i=t1.indexmin(); i<=t1.indexmax(); i++)
  {
    tmp.elem_value(i)=t1.elem_value(i)-x;
  }
  DF_FILE* fp = gradient_structure::fp;
  fp->save_dvar_vector_position(tmp);
  fp->save_dvar_vector_position(t1);
  save_identifier_string("dduu");
  gs->RETURN_ARRAYS_DECREMENT();
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dv_cdble_diff);
  return(tmp);
}

/**
Adjoint function for operator-(const dvar_vector&, const double)
*/
void DF_dv_cdble_diff(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("dduu");
  dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
  verify_identifier_string("ucbb");
  //double xinv=1./x;
  for (int i=t1_pos.indexmax(); i>=t1_pos.indexmin(); i--)
  {
    // tmp.elem_value(i)=t1.elem_value(i)-value(x);
    //tmp.elem_value(i)=value(x)*t1.elem_value(i)/value(x);
    dft1(i)=dftmp(i);
  }
  dft1.save_dvector_derivatives(t1_pos);
}

  void DF_dv_dble_prod(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const dvar_vector& t1,const prevariable& x)
{
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;

  gs->RETURN_ARRAYS_INCREMENT();

  int min = t1.indexmin();
  int max = t1.indexmax();
  dvar_vector tmp(min, max);
  //save_identifier_string("ccbb");
  fp->save_prevariable_value(x);
  fp->save_prevariable_position(x);

  const double valuex = value(x);
  double_and_int* ptmpi = tmp.va + min;
  double_and_int* pt1i = t1.va + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = pt1i->x * valuex;
    ++ptmpi;
    ++pt1i;
  }

  fp->save_dvar_vector_value(t1);
  fp->save_dvar_vector_position(tmp);
  fp->save_dvar_vector_position(t1);
  //save_identifier_string("DDaa");
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dv_dble_prod);

  gs->RETURN_ARRAYS_DECREMENT();

  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dv_dble_prod(void)
{
  DF_FILE* fp = gradient_structure::fp;

  //verify_identifier_string("DDaa");
  dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector t1=restore_dvar_vector_value(tmp_pos);
  prevariable_position xpos=fp->restore_prevariable_position();
  double x=fp->restore_prevariable_value();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  int min = t1_pos.indexmin();
  int max = t1_pos.indexmax();
  dvector dft1(min, max);
  //verify_identifier_string("ccbb");
  double dfx = 0.0;
  double* pdftmpi = dftmp.get_v() + max;
  double* pdft1i = dft1.get_v() + max;
  double* pt1i = t1.get_v() + max;
  for (int i = max; i >= min; --i)
  {
      //tmp.elem_value(i)=value(x)*t1.elem_value(i)*value(x);
      dfx += *pdftmpi * *pt1i;
      *pdft1i = *pdftmpi * x;

      --pdftmpi;
      --pdft1i;
      --pt1i;
  }
  save_double_derivative(dfx,xpos);
  dft1.save_dvector_derivatives(t1_pos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator*(const prevariable& x, const dvar_vector& t1)
  {
    return t1*x;
  }

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator+(const dvar_vector& t1, const prevariable& x)
{
  return x + t1;
}

void DF_dble_dv_add(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator+(const prevariable& x, const dvar_vector& t1)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  DF_FILE* fp = gradient_structure::fp;

  int min = t1.indexmin();
  int max = t1.indexmax();
  dvar_vector tmp(min, max);
  save_identifier_string("wcbf");
  fp->save_prevariable_position(x);
  double valuex = value(x);
  double_and_int* pt1i = t1.va + min;
  double_and_int* ptmpi = tmp.va + min;
  for (int i = min; i <= max; ++i)
  {
    ptmpi->x = pt1i->x + valuex;

    ++pt1i;
    ++ptmpi;
  }

  fp->save_dvar_vector_position(tmp);
  fp->save_dvar_vector_position(t1);
  save_identifier_string("dduu");
  gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dble_dv_add);

  gs->RETURN_ARRAYS_DECREMENT();

  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dble_dv_add(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("dduu");
  dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  prevariable_position xpos=fp->restore_prevariable_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  int min = t1_pos.indexmin();
  int max = t1_pos.indexmax();
  dvector dft1(min, max);
  verify_identifier_string("wcbf");
  //double xinv=1./x;
  double dfx = 0.0;
  double* pdftmpi = dftmp.get_v() + max;
  double* pdft1i = dft1.get_v() + max;
  for (int i = max; i >= min; --i)
  {
    // tmp.elem_value(i)=value(x)+t1.elem_value(i);
    //tmp.elem_value(i)=value(x)*t1.elem_value(i)/value(x);
    dfx += *pdftmpi;
    *pdft1i = *pdftmpi;

    --pdftmpi;
    --pdft1i;
  }
  save_double_derivative(dfx,xpos);
  dft1.save_dvector_derivatives(t1_pos);
}

  void DF_dble_dv_diff(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator-(const prevariable& x, const dvar_vector& t1)
  {
    gradient_structure* gs = gradient_structure::_instance;
    DF_FILE* fp = gradient_structure::fp;
    gs->RETURN_ARRAYS_INCREMENT();
    dvar_vector tmp(t1.indexmin(),t1.indexmax());
    save_identifier_string("wcbb");
    fp->save_prevariable_position(x);
    for (int i=t1.indexmin(); i<=t1.indexmax(); i++)
    {
      tmp.elem_value(i)=value(x)-t1.elem_value(i);
    }
    fp->save_dvar_vector_position(tmp);
    fp->save_dvar_vector_position(t1);
    save_identifier_string("dduu");
    gs->RETURN_ARRAYS_DECREMENT();
    gradient_structure::GRAD_STACK1->set_gradient_stack(DF_dble_dv_diff);
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_dble_dv_diff(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("dduu");
    dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
    dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
    prevariable_position xpos=fp->restore_prevariable_position();
    dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
    dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
    verify_identifier_string("wcbb");
    //double xinv=1./x;
    double dfx=0.;
    for (int i=t1_pos.indexmax(); i>=t1_pos.indexmin(); i--)
    {
       // tmp.elem_value(i)=value(x)-t1.elem_value(i);
      //tmp.elem_value(i)=value(x)*t1.elem_value(i)/value(x);
      dfx+=dftmp(i);
      dft1(i)=-dftmp(i);
    }
    save_double_derivative(dfx,xpos);
    dft1.save_dvector_derivatives(t1_pos);
 }

  void DF_dv_dble_diff(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator-(const dvar_vector& t1, const prevariable& x)
  {
    gradient_structure* gs = gradient_structure::_instance;
    DF_FILE* fp = gradient_structure::fp;
    gs->RETURN_ARRAYS_INCREMENT();
    dvar_vector tmp(t1.indexmin(),t1.indexmax());
    save_identifier_string("zcbb");
    fp->save_prevariable_position(x);
    for (int i=t1.indexmin(); i<=t1.indexmax(); i++)
    {
      tmp.elem_value(i)=t1.elem_value(i)-value(x);
    }
    fp->save_dvar_vector_position(tmp);
    fp->save_dvar_vector_position(t1);
    save_identifier_string("dduu");
    gs->RETURN_ARRAYS_DECREMENT();
    gs->GRAD_STACK1->set_gradient_stack(DF_dv_dble_diff);
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_dv_dble_diff(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("dduu");
    dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
    dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
    prevariable_position xpos=fp->restore_prevariable_position();
    dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
    dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
    verify_identifier_string("zcbb");
    //double xinv=1./x;
    double dfx=0.;
    for (int i=t1_pos.indexmax(); i>=t1_pos.indexmin(); i--)
    {
       // tmp.elem_value(i)=t1.elem_value(i)-value(x);
      //tmp.elem_value(i)=value(x)*t1.elem_value(i)/value(x);
      dfx-=dftmp(i);
      dft1(i)=dftmp(i);
    }
    save_double_derivative(dfx,xpos);
    dft1.save_dvector_derivatives(t1_pos);
 }

  void DF_dv_cdble_div(void);

/**
Divides each element of t1 by x, then return result in dvar_vector.

@param t1 dvar_vector
@param x divisor
@return dvar_vector result of operation
*/
dvar_vector operator/(const dvar_vector& t1, const double x)
  {
    gradient_structure* gs = gradient_structure::_instance;
    DF_FILE* fp = gradient_structure::fp;
    gs->RETURN_ARRAYS_INCREMENT();
    dvar_vector tmp(t1.indexmin(),t1.indexmax());
    save_identifier_string("ccxb");
    fp->save_double_value(x);
    for (int i=t1.indexmin(); i<=t1.indexmax(); i++)
    {
      tmp.elem_value(i)=t1.elem_value(i)/x;
    }
    fp->save_dvar_vector_value(tmp);
    fp->save_dvar_vector_position(tmp);
    fp->save_dvar_vector_position(t1);
    save_identifier_string("ddba");
    gs->RETURN_ARRAYS_DECREMENT();
    gs->GRAD_STACK1->set_gradient_stack(DF_dv_cdble_div);
    return(tmp);
  }

/**
Adjoint function for dvar_vector operator/(const dvar_vector&, const double)
*/
 void DF_dv_cdble_div(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("ddba");
    dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
    dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
    dvector tmp=restore_dvar_vector_value(tmp_pos);
    double x=fp->restore_prevariable_value();
    dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
    dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
    verify_identifier_string("ccxb");
    double xinv=1./x;
    for (int i=t1_pos.indexmax(); i>=t1_pos.indexmin(); i--)
    {
      //tmp.elem_value(i)=value(x)*t1.elem_value(i)/x;
      dft1(i)=dftmp(i)*xinv;
    }
    dft1.save_dvector_derivatives(t1_pos);
 }

  void DF_dv_dble_div(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator/(const dvar_vector& t1, const prevariable& x)
  {
    gradient_structure* gs = gradient_structure::_instance;
    DF_FILE* fp = gradient_structure::fp;
    gs->RETURN_ARRAYS_INCREMENT();
    dvar_vector tmp(t1.indexmin(),t1.indexmax());
    save_identifier_string("ccbb");
    fp->save_prevariable_value(x);
    fp->save_prevariable_position(x);
    int min = t1.indexmin();
    int max = t1.indexmax();
    double_and_int* ptmp = tmp.va + min;
    double_and_int* pt1 = t1.va + min;
    double value_x = value(x);
    for (int i = min; i <= max; ++i)
    {
      //tmp.elem_value(i)=t1.elem_value(i)/value(x);
      ptmp->x = pt1->x / value_x;
      ++ptmp;
      ++pt1;
    }
    fp->save_dvar_vector_value(tmp);
    fp->save_dvar_vector_position(tmp);
    fp->save_dvar_vector_position(t1);
    save_identifier_string("ddaa");
    gs->GRAD_STACK1->set_gradient_stack(DF_dv_dble_div);
    gs->RETURN_ARRAYS_DECREMENT();
    return(tmp);
  }

/**
 * Description not yet available.
 * \param
 */
 void DF_dv_dble_div(void)
 {
    DF_FILE* fp = gradient_structure::fp;

    verify_identifier_string("ddaa");
    dvar_vector_position t1_pos=fp->restore_dvar_vector_position();
    dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
    dvector tmp=restore_dvar_vector_value(tmp_pos);
    prevariable_position xpos=fp->restore_prevariable_position();
    double x=fp->restore_prevariable_value();
    dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
    dvector dft1(t1_pos.indexmin(),t1_pos.indexmax());
    verify_identifier_string("ccbb");
    double xinv=1.0 / x;
    double dfx=0.0;

    int min = t1_pos.indexmin();
    int max = t1_pos.indexmax();
    double* pdftmp = dftmp.get_v() + max;
    double* ptmp = tmp.get_v() + max;
    double* pdft1 = dft1.get_v() + max;
    for (int i = max; i >= min; --i)
    {
      //tmp.elem_value(i)=value(x)*t1.elem_value(i)/value(x);
      dfx -= *pdftmp * (*ptmp) * xinv;
      *pdft1 = *pdftmp * xinv;
      --pdftmp;
      --ptmp;
      --pdft1;
    }
    save_double_derivative(dfx,xpos);
    dft1.save_dvector_derivatives(t1_pos);
 }

#ifdef DEBUG
  #include <cassert>
  #include <climits>
#endif

void dv_subassign(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector dvar_vector::operator()(const ivector& u)
 {
   dvar_vector tmp(u.indexmin(),u.indexmax());

   for (int i=u.indexmin();i<=u.indexmax();i++)
   {
     tmp.elem_value(i)=elem_value(u(i));
   }

   grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
   DF_FILE* fp = gradient_structure::fp;
   save_identifier_string("by");
   fp->save_dvar_vector_position(*this);
   fp->save_dvar_vector_position(tmp);
   fp->save_ivector_value(u);
   fp->save_ivector_position(u);
   save_identifier_string("ay");
   GRAD_STACK1->set_gradient_stack(dv_subassign);

   return tmp;
 }

/**
 * Description not yet available.
 * \param
 */
void dv_subassign()
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("ay");
  ivector_position u_pos=fp->restore_ivector_position();
  ivector u=restore_ivector_value(u_pos);
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position t_pos=fp->restore_dvar_vector_position();
  dvector dft(t_pos.indexmin(),t_pos.indexmax());
  verify_identifier_string("by");
  dft.initialize();
  int mmin=dftmp.indexmin();
  int mmax=dftmp.indexmax();
  for (int i=mmin;i<=mmax;i++)
  {
     //tmp.elem_value(i)=this->elem_value(u(i));
     dft.elem(u(i))+=dftmp.elem(i);
  }
  dft.save_dvector_derivatives(t_pos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector dvar_vector::operator()(const lvector& u)
 {
   dvar_vector tmp(u.indexmin(),u.indexmax());
   for ( int i=u.indexmin(); i<=u.indexmax(); i++)
   {
#ifdef DEBUG
     assert(u(i) <= INT_MAX);
#endif
     tmp(i)=(*this)((int)u(i));
   }
   return tmp;
 }

/**
 * Description not yet available.
 * \param
 */
dvar_vector colsum(const dvar_matrix& v)
{
  int cmin=v.colmin();
  int cmax=v.colmax();
  int rmin=v.rowmin();
  int rmax=v.rowmax();

  dvar_vector tmp(cmin, cmax);
  tmp.initialize();
  for (int j = cmin; j <= cmax; ++j)
  {
    for (int i = rmin; i <= rmax; ++i)
    {
      tmp(j) += v(i, j);
    }
  }
  return tmp;
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector rowsum(const dvar_matrix& v)
{
  //int cmin=v.colmin();
  //int cmax=v.colmax();
  int rmin=v.rowmin();
  int rmax=v.rowmax();

  dvar_vector tmp(rmin, rmax);
  const dvar_vector* pvi = &v(rmin);
  for (int i = rmin; i <= rmax; ++i)
  {
    tmp(i) = sum(*pvi);
    ++pvi;
  }
  return tmp;
}

void dv_xminuseq(void);

/**
Substracts d from each element of dvar_vector.

@param d prevariable
*/
dvar_vector& dvar_vector::operator-=(const prevariable& d)
{
  dvar_vector::operator-=(value(d));

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("Pvv");
  fp->save_dvar_vector_position(*this);  // for this->
  fp->save_prevariable_position(d);
  save_identifier_string("Pxx");
  GRAD_STACK1->set_gradient_stack(dv_xminuseq);

  return *this;
}
/**
Adjoint function to compute gradients for dvar_vector::operator-=(const prevariable&)
*/
void dv_xminuseq(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("Pxx");
  prevariable_position d_pos=fp->restore_prevariable_position();
  dvar_vector_position this_pos=fp->restore_dvar_vector_position();
  verify_identifier_string("Pvv");
  dvector dfthis=restore_dvar_vector_der_nozero(this_pos);
  double temp=-sum(dfthis);
  save_double_derivative(temp,d_pos);
}

void dv_xpluseq(void);

/**
Adds d to each element of dvar_vector.

@param d prevariable
*/
dvar_vector& dvar_vector::operator+=(const prevariable& d)
{
  dvar_vector::operator+=(value(d));

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("Qvv");
  fp->save_dvar_vector_position(*this);  // for this->
  fp->save_prevariable_position(d);
  save_identifier_string("Qxx");
  GRAD_STACK1->set_gradient_stack(dv_xpluseq);

  return *this;
}
/**
Adjoint function to compute gradients for dvar_vector::operator+=(const prevariable&).
*/
void dv_xpluseq(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("Qxx");
  prevariable_position d_pos=fp->restore_prevariable_position();
  dvar_vector_position this_pos=fp->restore_dvar_vector_position();
  verify_identifier_string("Qvv");
  dvector dfthis=restore_dvar_vector_der_nozero(this_pos);
  double temp=sum(dfthis);
  save_double_derivative(temp,d_pos);
}
/**
Substracts d from each element of dvar_vector.

@param d double
*/
dvar_vector& dvar_vector::operator-=(double d)
{
  double_and_int* pv = va + index_min;
  for (int i = index_min; i <= index_max; ++i)
  {
    pv->x -= d;
    ++pv;
  }

  return *this;
}
/**
Adds d to each element of dvar_vector.

@param d double
*/
dvar_vector& dvar_vector::operator+=(double d)
{
  double_and_int* pv = va + index_min;
  for (int i = index_min; i <= index_max; ++i)
  {
    pv->x += d;
    ++pv;
  }

  return *this;
}
#ifdef DEBUG
  #include <cassert>
  #include <cfenv>
  #include <cstdlib>
#endif

/*
//  "template" for precompiled derivative code
 //   change XXX to function name and YYY to derivative function name
void DF_dvXXX(void);
dvar_vector XXX(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=XXX(v1.elem_value(i));
  }

  gradient_structure* gs = gradient_structure::get();
  DF_FILE* fp = gs->fp;

  save_identifier_string("ddd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eee");
  gs->GRAD_STACK1->set_gradient_stack(DF_dvXXX);
  return vtmp;
}

void DF_dvXXX(void)
{
  gradient_structure* gs = gradient_structure::get();
  DF_FILE* fp = gs->fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("eee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ddd");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    dfv1(i)=dfvtmp(i)*YYY(v1.elem(i));
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

*/


void DF_dvsin(void);

/**
Computes sin of each element in v1 to a dvar_vector.

@param v1 dvar_vector
*/
dvar_vector sin(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=sin(v1.elem_value(i));
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eee");
  GRAD_STACK1->set_gradient_stack(DF_dvsin);

  return vtmp;
}
/**
Adjoint function to compute gradients for sin(const dvar_vector&)
*/
void DF_dvsin(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("eee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ddd");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    dfv1(i)=dfvtmp(i)*cos(v1.elem(i));
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvexp(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector exp(const dvar_vector& v1)
{
  int min = v1.indexmin();
  int max = v1.indexmax();
  //dvector cv1=value(v1);
  dvar_vector vtmp(min, max);
  double_and_int* pvtmp = vtmp.va + min;
  double_and_int* pv1 = v1.va + min;
  for (int i = min; i <= max; ++i)
  {
    pvtmp->x = exp(pv1->x);
    ++pvtmp;
    ++pv1;
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddd");
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_value(vtmp);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("hee");
  GRAD_STACK1->set_gradient_stack(DF_dvexp);

  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dvexp(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("hee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvector vtmp=restore_dvar_vector_value(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  verify_identifier_string("ddd");
  int min = dfvtmp.indexmin();
  int max = dfvtmp.indexmax();
  dvector dfv1(min, max);
  double* pdfv1 = dfv1.get_v() + min;
  double* pvtmp = vtmp.get_v() + min;
  double* pdfvtmp = dfvtmp.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    *pdfv1 = *pdfvtmp * *pvtmp;
    ++pdfv1;
    ++pvtmp;
    ++pdfvtmp;
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}


void DF_dvcos(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector cos(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=cos(v1.elem_value(i));
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("cee");
  GRAD_STACK1->set_gradient_stack(DF_dvcos);

  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dvcos(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("cee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ddd");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    dfv1(i)=-dfvtmp(i)*sin(v1.elem(i));
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvlog(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector log(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  int min = v1.indexmin();
  int max = v1.indexmax();
  dvar_vector vtmp(min, max);
  double_and_int* pvtmp = vtmp.va + min;
  double_and_int* pv1 = v1.va + min;
  for (int i = min; i <= max; ++i)
  {
    pvtmp->x = log(pv1->x);
    ++pvtmp;
    ++pv1;
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("cdd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eee");
  GRAD_STACK1->set_gradient_stack(DF_dvlog);

  return vtmp;
}

#ifdef DEBUG
int ad_debug_arithmetic=1;
#endif

/**
 * Description not yet available.
 * \param
 */
void DF_dvlog(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("eee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("cdd");

  int min = dfvtmp.indexmin();
  int max = dfvtmp.indexmax();
  dvector dfv1(min, max);
  double* pdfv1 = dfv1.get_v() + min;
  double* pv1 = v1.get_v() + min;
  double* pdfvtmp = dfvtmp.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
#ifdef DEBUG
     if (ad_debug_arithmetic==1)
      if (v1.elem(i)==0.0 || fabs(v1.elem(i))<1.e-150 ||
        dfvtmp(i) > 1.e+150)
      {
        cerr << "Possible overflow in DF_dvlog" << endl;
      }
#endif
    *pdfv1 = *pdfvtmp / *pv1;
    ++pdfv1;
    ++pv1;
    ++pdfvtmp;
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvtan(void);

/**
Computes tan of each element in v1 to a dvar_vector.

@param v1 dvar_vector
*/
dvar_vector tan(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=tan(v1.elem_value(i));
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("xee");
  GRAD_STACK1-> set_gradient_stack(DF_dvtan);

  return vtmp;
}
/**
Adjoint function to compute gradients for tan(const dvar_vector&).
*/
void DF_dvtan(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("xee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ddd");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=tan(value(v1.elem(i))));
    dfv1(i)=dfvtmp(i)/pow(cos(v1.elem(i)),2);
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvatan(void);

/**
Computes atan of each element in v1 to a dvar_vector.

@param v1 dvar_vector
*/
dvar_vector atan(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=atan(v1.elem_value(i));
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("udd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eee");
  GRAD_STACK1->set_gradient_stack(DF_dvatan);

  return vtmp;
}
/**
Adjoint function to compute gradients for tan(const dvar_vector&).
*/
void DF_dvatan(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("eee");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("udd");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    dfv1(i)=dfvtmp(i)/(1.+pow(v1.elem(i),2));
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvsqrt(void);

/**
Computes sqrt of each element in v1 to a dvar_vector.

@param v1 dvar_vector
*/
dvar_vector sqrt(const dvar_vector& v1)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=sqrt(v1.elem_value(i));
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eve");
  GRAD_STACK1->set_gradient_stack(DF_dvsqrt);

  return vtmp;
}
/**
Computes square of each element in v1 to a dvar_vector.

@param v1 dvar_vector
*/
dvar_vector sqr(const dvar_vector& v1)
{
  /*
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=sqrt(v1.elem_value(i));
  }

  gradient_structure* gs = gradient_structure::get();
  DF_FILE* fp = gs->fp;
  save_identifier_string("ddd");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eve");
  gs->GRAD_STACK1->set_gradient_stack(DF_dvsqrt);
  return vtmp;
  */

  return pow(v1, 2.0);
}
/**
Adjoint function to compute gradients for sqrt(const dvar_vector&).
*/
void DF_dvsqrt(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("eve");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ddd");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    dfv1(i)=dfvtmp(i)/(2*sqrt(v1.elem(i)));
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvpow(void);

/**
Computes pow raised to the power e for each element in v1 to a dvar_vector.

@param v1 dvar_vector
*/
dvar_vector pow(const dvar_vector& v1, const double e)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
#ifdef DEBUG
    if (v1.elem_value(i) == 0.0 && e < 1.0)
    {
      cerr << "Warning: Invalid arguments to be used in derivative computation.\n"
	   << "         pow(" << v1.elem_value(i) << ", " << (e - 1.0 ) << ")" << endl;
    }
#endif
    vtmp.elem_value(i)=pow(v1.elem_value(i),e);
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddf");
  fp->save_dvar_vector_value(v1);
  fp->save_double_value(e);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eef");
  GRAD_STACK1->set_gradient_stack(DF_dvpow);

  return vtmp;
}
/**
Adjoint function to compute gradients for pow(const dvar_vector&, const double).
*/
void DF_dvpow(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("eef");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  double e=fp->restore_double_value();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ddf");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());

#ifdef DEBUG
  if (std::fetestexcept(FE_INVALID))
  {
    cerr << "Warning: FE_INVALID in " << __FILE__ << ':' << __LINE__ << endl;
    std::feclearexcept(FE_INVALID);
  }
#endif
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    dfv1(i)=dfvtmp(i)*e*pow(v1.elem(i),e-1);
#ifdef DEBUG
    if (std::fetestexcept(FE_INVALID))
    {
      cerr << "Warning: FE_INVALID in " << __FILE__ << ':' << __LINE__ << endl;
      std::feclearexcept(FE_INVALID);
    }
#endif
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}


//  Don't have the functions for savinf and restoring
//    prevariables as yet

void DF_dvdvpow(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector pow(const dvar_vector& v1, const prevariable& e)
{
  //dvector cv1=value(v1);
  double ce=value(e);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=pow(v1.elem_value(i),ce);
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddg");
  fp->save_prevariable_value(e);
  fp->save_prevariable_position(e);
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eeg");
  GRAD_STACK1->set_gradient_stack(DF_dvdvpow);

  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dvdvpow(void)
{
  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("eeg");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector v1=restore_dvar_vector_value(v1pos);
  prevariable_position epos=fp->restore_prevariable_position();
  double e=fp->restore_prevariable_value();
  verify_identifier_string("ddg");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  double dfe=0.;
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    double tmp=pow(v1.elem(i),e-1);
    //vtmp.elem(i)=pow(value(v1.elem(i)),e);
    dfv1(i)=dfvtmp(i)*e*tmp;
    dfe+=dfvtmp(i)*v1.elem(i)*tmp*log(v1.elem(i));
  }
  dfv1.save_dvector_derivatives(v1pos);
  save_double_derivative(dfe,epos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_dvcpow(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector pow(const dvar_vector& v1,int e)
{
  //dvector cv1=value(v1);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=pow(v1.elem_value(i),e);
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("ddf");
  fp->save_dvar_vector_value(v1);
  fp->save_double_value(double(e));
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("eef");
  GRAD_STACK1->set_gradient_stack(DF_dvcpow);

  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_dvcpow(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("eef");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  double e=fp->restore_double_value();
  dvector v1=restore_dvar_vector_value(v1pos);
  verify_identifier_string("ddf");
  dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    //vtmp.elem(i)=sin(value(v1.elem(i))));
    dfv1(i)=dfvtmp(i)*e*pow(v1.elem(i),e-1);
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

void DF_cdvpow(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector pow(const dvector& v1,const prevariable& e)
{
  //dvector cv1=value(v1);
  double ce=value(e);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=pow(v1.elem(i),ce);
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  save_identifier_string("eddg");
  fp->save_prevariable_value(e);
  fp->save_prevariable_position(e);
  fp->save_dvector_value(v1);
  fp->save_dvector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("feeg");
  GRAD_STACK1->set_gradient_stack(DF_cdvpow);

  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void DF_cdvpow(void)
{
  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("feeg");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dfvtmp=restore_dvar_vector_derivatives(tmp_pos);
  dvector_position v1pos=fp->restore_dvector_position();
  dvector v1=fp->restore_dvector_value(v1pos);
  prevariable_position epos=fp->restore_prevariable_position();
  double e=fp->restore_prevariable_value();
  verify_identifier_string("eddg");
  //dvector dfv1(dfvtmp.indexmin(),dfvtmp.indexmax());
  double dfe=0.;
  for (int i=dfvtmp.indexmin();i<=dfvtmp.indexmax();i++)
  {
    double tmp=pow(v1.elem(i),e);
    //vtmp.elem(i)=pow(value(v1.elem(i)),e);
    //dfv1(i)=dfvtmp(i)*e*tmp;
    dfe+=dfvtmp(i)*tmp*log(v1.elem(i));
  }
  //dfv1.save_dvector_derivatives(v1pos);
  save_double_derivative(dfe,epos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}
dvar_vector pow(const dvector& x,const dvar_vector& a)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  dvar_vector y(x.indexmin(), x.indexmax());
  for(int i=x.indexmin(); i<=x.indexmax(); i++)
  {
    y(i)=pow(x(i),a(i));
  }

  gs->RETURN_ARRAYS_DECREMENT();

  return y;
}

/**
Returns diagonal of variable matrix m.
\param m square dvar_matrix
*/
dvar_vector extract_diagonal(const dvar_matrix& m)
{
#ifndef OPT_LIB
  if ((m.rowmin() != m.colmin()) || (m.rowmax() != m.colmax()))
  {
    cerr << "Error in extract_diagonal function -- input matrix not square\n";
    ad_exit(1);
  }
#endif
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  dvar_vector diagonal(m.rowmin(), m.rowmax());

  for (int i = m.rowmin(); i <= m.rowmax(); ++i)
  {
      diagonal.elem(i) = m.elem(i,i);
  }

  gs->RETURN_ARRAYS_DECREMENT();

  return diagonal;
}
#if defined(__TURBOC__)
  #pragma hdrstop
  #include <alloc.h>
#endif

#include <stdlib.h>

/**
 * Description not yet available.
 * \param
 */
 dvar_vector& dvar_vector::operator=(const dvector& t)
 {
#ifndef OPT_LIB
   if (indexmin() != t.indexmin() || indexmax() != t.indexmax())
   {
     cerr << "Incompatible bounds in "
	  << "dvar_vector& dvar_vector::operator=(const dvector&)\n";
     ad_exit(21);
   }
#endif

   for ( int i=indexmin(); i<=indexmax(); i++)
   {
     va[i].x=t[i];
   }

   grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
   DF_FILE* fp = gradient_structure::fp;
   save_identifier_string("b");
   fp->save_dvar_vector_position(*this);
   save_identifier_string("a");
   GRAD_STACK1->set_gradient_stack(dv_init);

   return *this;
 }

void dv_minuseq(void);

/**
 * Description not yet available.
 * \param
 */
 dvar_vector& dvar_vector::operator-=(const dvar_vector& v1)
 {
#ifndef OPT_LIB
   if (indexmin() != v1.indexmin() || indexmax() != v1.indexmax())
   {
     cerr << "Incompatible array bounds in "
	  << "dvar_vector& dvar_vector::operator-=(const dvar_vector&).\n";
     ad_exit(21);
   }
#endif

   {
     for (int i=indexmin();i<=indexmax();i++)
     {
       elem_value(i) -= v1.elem_value(i);
     }
   }
   grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
   DF_FILE* fp = gradient_structure::fp;
   save_identifier_string("uuvv");
   fp->save_dvar_vector_position(*this);  // for this->
   fp->save_dvar_vector_position(v1);
   save_identifier_string("wwxx");
   GRAD_STACK1->set_gradient_stack(dv_minuseq);

   return *this;
 }

/**
 * Description not yet available.
 * \param
 */
void dv_minuseq(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("wwxx");
  dvar_vector_position v1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position this_pos=fp->restore_dvar_vector_position();
  verify_identifier_string("uuvv");
  dvector dfthis=-1.*restore_dvar_vector_der_nozero(this_pos);
  dfthis.save_dvector_derivatives(v1_pos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector& dvar_vector::operator-=(const dvector& v1)
 {
   if (indexmin() != v1.indexmin() || indexmax() != v1.indexmax())
   {
     cerr << " Incompatible array bounds in "
     "dvector& operator += (const dvar_vector&)\n";
     ad_exit(21);
   }

   {
     for (int i=indexmin();i<=indexmax();i++)
     {
       elem_value(i) -= v1.elem(i);
     }
   }
   return(*this);
 }

void dv_pluseq(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector& dvar_vector::operator+=(const dvar_vector& v1)
{
  int min = v1.indexmin();
  int max = v1.indexmax();

#ifndef OPT_LIB
  if (indexmin() != v1.indexmin() || indexmax() != v1.indexmax())
  {
    cerr << " Incompatible array bounds in dvector& operator+=(const dvar_vector&)\n";
    ad_exit(21);
  }
#endif

  double_and_int* pvai = va + min;
  double_and_int* pv1i = v1.va + min;
  for (int i = min; i <= max; ++i)
  {
    pvai->x += pv1i->x;

    ++pvai;
    ++pv1i;
  }

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  //save_identifier_string("uuvv");
  fp->save_dvar_vector_position(*this);  // for this->
  fp->save_dvar_vector_position(v1);
  //save_identifier_string("wwxx");
  GRAD_STACK1->set_gradient_stack(dv_pluseq);

  return *this;
}

/**
 * Description not yet available.
 * \param
 */
void dv_pluseq(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  //verify_identifier_string("wwxx");
  dvar_vector_position v1_pos=fp->restore_dvar_vector_position();
  dvar_vector_position this_pos=fp->restore_dvar_vector_position();
  //verify_identifier_string("uuvv");
  dvector dfthis=restore_dvar_vector_der_nozero(this_pos);
  dfthis.save_dvector_derivatives(v1_pos);
}

/**
 * Description not yet available.
 * \param
 */
dvar_vector& dvar_vector::operator+=(const dvector& v1)
{
  int min = v1.indexmin();
  int max = v1.indexmax();
  if (indexmin() != v1.indexmin() || indexmax() != v1.indexmax())
  {
    cerr << " Incompatible array bounds in dvector& operator+=(const dvar_vector&)\n";
    ad_exit(21);
  }
  double* pv1i = v1.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    elem_value(i) += *pv1i;

    ++pv1i;
  }
  return *this;
}

/**
 * Description not yet available.
 * \param
 */
  void dvar_vector::initialize(void)
  {
    if (!(!(*this)))  // only initialize allocated objects
    {
      for (int i=indexmin();i<=indexmax();i++)
      {
        //this->elem(i)=0.0;
        va[i].x=0.0;
      }
      grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
      DF_FILE* fp = gradient_structure::fp;
      save_identifier_string("b");
      fp->save_dvar_vector_position(*this);
      save_identifier_string("a");
      GRAD_STACK1->set_gradient_stack(dv_init);
    }
  }


/**
 * Description not yet available.
 * \param
 */
void dv_init(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("a");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  verify_identifier_string("b");
  dvector dftmp(tmp_pos.indexmin(),tmp_pos.indexmax());
  for (int i=dftmp.indexmin();i<=dftmp.indexmax();i++)
  {
    //vtmp.elem(i)=value(v1.elem(i))+value(v2.elem(i));
    dftmp.elem(i)=0.0;
  }
  dftmp.save_dvector_derivatives_na(tmp_pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}


/**
 * Description not yet available.
 * \param
 */
void dvar_vector::initialize(const dvector& ww)
  {
      if (indexmin() != ww.indexmin() ||  indexmax() != ww.indexmax())
      {
        cerr << "Index bounds do not match in "
              "void dvar_vector::initialize(const dvector& ww)"<<endl;
        ad_exit(1);
      }

    for (int i=indexmin();i<=indexmax();i++)
    {
      //this->elem(i)=0.0;
      va[i].x=ww.elem(i);
    }
    grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
    DF_FILE* fp = gradient_structure::fp;
    save_identifier_string("b");
    fp->save_dvar_vector_position(*this);
    save_identifier_string("a");
    GRAD_STACK1->set_gradient_stack(dv_init);
  }
void dvcv_sub(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator-(const dvar_vector& v1, const dvector& v2)
{
  int min = v1.indexmin();
  int max = v1.indexmax();

#ifndef OPT_LIB
  if (min != v2.indexmin() || max != v2.indexmax())
  {
    cerr << "Incompatible bounds in prevariable operator-(const dvar_vector&, const dvector&)\n";
    ad_exit(1);
  }
#endif

  //dvector cv1=value(v1);
  //dvector cv2=value(v2);
  dvar_vector vtmp(min, max);

  double_and_int* pvtmp = vtmp.va;
  double_and_int* pv1 = v1.va;
  double* pv2 = v2.get_v();
  for (int i = min; i <= max; ++i)
  {
    pvtmp[i].x = pv1[i].x - pv2[i];
  }

  //dvar_vector vtmp=nograd_assign(tmp);
  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  // The derivative list considerations
  save_identifier_string("bbbb");
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("aaaa");
  GRAD_STACK1->set_gradient_stack(dvcv_sub);

  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void dvcv_sub(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("aaaa");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  verify_identifier_string("bbbb");

  int min = dftmp.indexmin();
  int max = dftmp.indexmax();
  dvector dfv1(min, max);
  double* pdfv1 = dfv1.get_v();
  double* pdftmp = dftmp.get_v();
  for (int i = min; i <= max; ++i)
  {
    //vtmp.elem(i)=value(v1.elem(i))+v2.elem(i);
    pdfv1[i] = pdftmp[i];
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}
void dvdv_sub(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator-(const dvar_vector& v1, const dvar_vector& v2)
{
#ifndef OPT_LIB
  if (v1.indexmin()!=v2.indexmin()||v1.indexmax()!=v2.indexmax())
  {
    cerr << "Incompatible bounds in "
	 << "dvar_vector operator-(const dvar_vector&,const dvar_vector&)\n";
    ad_exit(1);
  }
#endif
  //dvector cv1=value(v1);
  //dvector cv2=value(v2);
  kkludge_object kkk;
  dvar_vector vtmp(v1.indexmin(),v1.indexmax(),kkk);
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=v1.elem_value(i)-v2.elem_value(i);
  }

  //dvar_vector vtmp=nograd_assign(tmp);

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  // The derivative list considerations
  save_identifier_string("bbbb");
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(v2);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("aaaa");
  GRAD_STACK1->set_gradient_stack(dvdv_sub);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void dvdv_sub(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("aaaa");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  verify_identifier_string("bbbb");
  dvector dfv1(dftmp.indexmin(),dftmp.indexmax());
  dvector dfv2(dftmp.indexmin(),dftmp.indexmax());
  for (int i=dftmp.indexmin();i<=dftmp.indexmax();i++)
  {
    //vtmp.elem(i)=value(v1.elem(i))+value(v2.elem(i));
    dfv1.elem(i)=dftmp.elem(i);
    dfv2.elem(i)=-dftmp.elem(i);
  }
  dfv1.save_dvector_derivatives(v1pos);
  dfv2.save_dvector_derivatives(v2pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}
void cvdv_sub(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator-(const dvector& v1, const dvar_vector& v2)
{
#ifndef OPT_LIB
  if (v1.indexmin()!=v2.indexmin()||v1.indexmax()!=v2.indexmax())
  {
    cerr << "Incompatible bounds in "
      "prevariable operator-(const dvector& v1, const dvar_vector& v2)" << endl;
    ad_exit(1);
  }
#endif
  //dvector cv1=value(v1);
  //dvector cv2=value(v2);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=v1.elem(i)-v2.elem_value(i);
  }

  //dvar_vector vtmp=nograd_assign(tmp);

  DF_FILE* fp = gradient_structure::fp;

  // The derivative list considerations
#ifndef OPT_LIB
  save_identifier_string("bbbb");
#endif
  fp->save_dvar_vector_position(v2);
  fp->save_dvar_vector_position(vtmp);
#ifndef OPT_LIB
  save_identifier_string("aaaa");
#endif
  gradient_structure::_instance->GRAD_STACK1->set_gradient_stack(cvdv_sub);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void cvdv_sub(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
#ifndef OPT_LIB
  verify_identifier_string("aaaa");
#endif
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
#ifndef OPT_LIB
  verify_identifier_string("bbbb");
#endif
  dvector dfv2(dftmp.indexmin(),dftmp.indexmax());
  for (int i=dftmp.indexmin();i<=dftmp.indexmax();i++)
  {
    //vtmp.elem(i)=v1.elem(i)-value(v2.elem(i));
    dfv2(i)=-dftmp.elem(i);
  }
  dfv2.save_dvector_derivatives(v2pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}
#if defined(__TURBOC__)
  #pragma hdrstop
   #include <alloc.h>
#endif

#include <stdlib.h>

void dv_assign(void);

#ifdef _MSC_VER
  #include <memory.h>
#endif

#ifdef DEBUG
  #include <cassert>
#endif

/**
Assign values from other t to dvar_vector.

@param t other dvar_vector
*/
dvar_vector& dvar_vector::operator=(const dvar_vector& t)
 {
   if (!(*this))
   {
     allocatec(t);
   }
#if defined (AD_FAST_ASSIGN)
   else if (!(shape->ncopies))
   {
     deallocate();
     allocatec(t);
   }
#endif
   else
   {
     int mmin=indexmin();
     int mmax=indexmax();
#ifndef OPT_LIB
     if (mmin != t.indexmin() || mmax != t.indexmax())
     {
       cerr << " Incompatible bounds in dvar_vector& dvar_vector::operator ="
         " (const dvar_vector& t)\n";
       ad_exit(21);
     }
#endif
     if (va != t.va)
     {
       constexpr size_t sizeofdouble = sizeof(double);
       size_t size = (size_t)(mmax - mmin + 1);
       memcpy(va + mmin, t.va + mmin, size * sizeofdouble);

       grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
       DF_FILE* fp = gradient_structure::fp;
       // The derivative list considerations
       //save_identifier_string("bbbb");
       fp->save_dvar_vector_position(t);
       fp->save_dvar_vector_position(*this);
       //save_identifier_string("aaaa");
       GRAD_STACK1->set_gradient_stack(dv_assign);
     }
   }
   return (*this);
 }

void dv_eqprev(void);

/**
Assigns all elements for dvar_vector with t. 

@param t prevariable
*/
dvar_vector& dvar_vector::operator=(const prevariable& t)
 {
   int mmin=indexmin();
   int mmax=indexmax();
   double valuet = value(t);
   double_and_int* pvai = va + mmin;
   for (int i=mmin; i<=mmax; i++)
   {
     pvai->x = valuet;
     ++pvai;
   }

   grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
   DF_FILE* fp = gradient_structure::fp;
   // The derivative list considerations
   save_identifier_string("dddd");
   fp->save_prevariable_position(t);
   fp->save_dvar_vector_position(*this);
   save_identifier_string("ssss");
   GRAD_STACK1->set_gradient_stack(dv_eqprev);
   return (*this);
 }

void dv_eqdoub(void);

/**
Assigns all elements for dvar_vector with t. 

@param t single value
*/
dvar_vector& dvar_vector::operator=(const double t)
 {
   int mmin=indexmin();
   int mmax=indexmax();
   double_and_int* pvai = va + mmin;
   for (int i=mmin; i<=mmax; i++)
   {
     pvai->x = t;
     ++pvai;
   }
   grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
   DF_FILE* fp = gradient_structure::fp;
   // The derivative list considerations
   save_identifier_string("trut");
   fp->save_dvar_vector_position(*this);
   save_identifier_string("ssss");
   GRAD_STACK1->set_gradient_stack(dv_eqdoub);
   return (*this);
 }
/**
Adjoint to compute gradient for dvar_vector::operator=(const double).
*/
void dv_eqdoub(void)
{
  DF_FILE* fp = gradient_structure::fp;
  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("ssss");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  verify_identifier_string("trut");
}
/**
Adjoint to compute gradient for dvar_vector::operator=(const prevariable&).
*/
void dv_eqprev(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("ssss");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  prevariable_position t_pos=fp->restore_prevariable_position();
  verify_identifier_string("dddd");
  double dft = 0.0;
  int min = dftmp.indexmin();
  int max = dftmp.indexmax();
  double* pdftmpi = dftmp.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    //vtmp.elem(i)=t;
    dft += *pdftmpi;

    ++pdftmpi;
  }
  save_double_derivative(dft,t_pos);
}
/**
Adjoint to compute gradients for dvar_vector::operator=(const dvar_vector&)
*/
void dv_assign(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  //verify_identifier_string("aaaa");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position t_pos=fp->restore_dvar_vector_position();
  //verify_identifier_string("bbbb");

  int mmin=dftmp.indexmin();
  int mmax=dftmp.indexmax();

#ifdef DEBUG
  assert(mmax >= mmin);
#endif

  dvector dft(mmin, mmax);

  constexpr size_t sizeofdouble = sizeof(double);
  size_t size = (size_t)(mmax - mmin + 1);
  memcpy(dft.get_v() + mmin, dftmp.get_v() + mmin, size * sizeofdouble);

  dft.save_dvector_derivatives(t_pos);
}
void dvcv_add(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator+(const dvar_vector& v1, const dvector& v2)
{
  if (v1.indexmin()!=v2.indexmin()||v1.indexmax()!=v2.indexmax())
  {
    cerr << "Incompatible bounds in "
    "prevariable operator+(const dvar_vector& v1, const dvar_vector& v2)"
    << endl;
    ad_exit(1);
  }
  //dvector cv1=value(v1);
  //dvector cv2=value(v2);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=v1.elem_value(i)+v2.elem(i);
  }

  //dvar_vector vtmp=nograd_assign(tmp);
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;

  // The derivative list considerations
  save_identifier_string("bbbb");
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("aaaa");
  gs->GRAD_STACK1->set_gradient_stack(dvcv_add);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void dvcv_add(void)
{
  DF_FILE* fp = gradient_structure::fp;
  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("aaaa");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  verify_identifier_string("bbbb");
  dvector dfv1(dftmp.indexmin(),dftmp.indexmax());
  for (int i=dftmp.indexmin();i<=dftmp.indexmax();i++)
  {
    //vtmp.elem(i)=value(v1.elem(i))+value(v2.elem(i));
    dfv1.elem(i)=dftmp.elem(i);
  }
  dfv1.save_dvector_derivatives(v1pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}
void cvdv_add(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator+(const dvector& v1, const dvar_vector& v2)
{
  if (v1.indexmin()!=v2.indexmin()||v1.indexmax()!=v2.indexmax())
  {
    cerr << "Incompatible bounds in "
    "prevariable operator+(const dvar_vector& v1, const dvar_vector& v2)"
    << endl;
    ad_exit(1);
  }
  //dvector cv1=value(v1);
  //dvector cv2=value(v2);
  dvar_vector vtmp(v1.indexmin(),v1.indexmax());
  for (int i=v1.indexmin();i<=v1.indexmax();i++)
  {
    vtmp.elem_value(i)=v1.elem(i)+v2.elem_value(i);
  }

  //dvar_vector vtmp=nograd_assign(tmp);
  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;

  // The derivative list considerations
  save_identifier_string("bbbb");
  fp->save_dvar_vector_position(v2);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("aaaa");
  gs->GRAD_STACK1->set_gradient_stack(cvdv_add);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void cvdv_add(void)
{
  DF_FILE* fp = gradient_structure::fp;
  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("aaaa");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  verify_identifier_string("bbbb");
  dvector dfv2(dftmp.indexmin(),dftmp.indexmax());
  for (int i=dftmp.indexmin();i<=dftmp.indexmax();i++)
  {
    //vtmp.elem(i)=value(v1.elem(i))+value(v2.elem(i));
    dfv2(i)=dftmp.elem(i);
  }
  dfv2.save_dvector_derivatives(v2pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}
#ifdef _MSC_VER
  #include <memory.h>
#endif

#ifdef DEBUG
  #include <cassert>
#endif

void dvdv_add(void);

/**
 * Description not yet available.
 * \param
 */
dvar_vector operator+(const dvar_vector& v1, const dvar_vector& v2)
{
  int mmin=v1.indexmin();
  int mmax=v1.indexmax();
#ifndef OPT_LIB
  if (mmin != v2.indexmin() || mmax != v2.indexmax())
  {
    cerr << "Incompatible bounds in "
	 << "dvar_vector operator+(const dvar_vector&, const dvar_vector&).\n";
    ad_exit(1);
  }
#endif
  //dvector cv1=value(v1);
  //dvector cv2=value(v2);
  kkludge_object kkk;
  dvar_vector vtmp(mmin, mmax, kkk);

#ifdef USE_ASSEMBLER
  int min=v1.indexmin();
  int n=v1.indexmax()-min+1;
  dp_vector_add(&(vtmp.elem_value(min)),&(v1.elem_value(min)),
    &(v2.elem_value(min)),n);
#else
  double_and_int* pvtmp = vtmp.va;
  double_and_int* pv1 = v1.va;
  double_and_int* pv2 = v2.va;
  for (int i = mmin; i <= mmax; ++i)
  {
    //vtmp.elem_value(i)=v1.elem_value(i)+v2.elem_value(i);
    pvtmp[i].x = pv1[i].x + pv2[i].x;
  }
#endif

  //dvar_vector vtmp=nograd_assign(tmp);

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  // The derivative list considerations
  save_identifier_string("bbbb");
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_position(v2);
  fp->save_dvar_vector_position(vtmp);
  save_identifier_string("aaaa");
  GRAD_STACK1->set_gradient_stack(dvdv_add);

  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void dvdv_add(void)
{
  DF_FILE* fp = gradient_structure::fp;

  // int ierr=fsetpos(gradient_structure::get_fp(),&filepos);
  verify_identifier_string("aaaa");
  dvar_vector_position tmp_pos=fp->restore_dvar_vector_position();
  dvector dftmp=restore_dvar_vector_derivatives(tmp_pos);
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  verify_identifier_string("bbbb");
  int mmin=dftmp.indexmin();
  int mmax=dftmp.indexmax();
#ifdef DEBUG
  assert(mmax >= mmin);
#endif
  dvector dfv1(mmin,mmax);
  dvector dfv2(mmin,mmax);
#ifdef OPT_LIB
  constexpr size_t sizeofdouble = sizeof(double);
  size_t size = (size_t)(mmax - mmin + 1) * sizeofdouble;
  memcpy(&dfv1.elem(mmin),&dftmp.elem(mmin), size);
  memcpy(&dfv2.elem(mmin),&dftmp.elem(mmin), size);
#else
  for (int i=dftmp.indexmin();i<=dftmp.indexmax();i++)
  {
    //vtmp.elem(i)=value(v1.elem(i))+value(v2.elem(i));
    dfv1(i)=dftmp.elem(i);
    dfv2(i)=dftmp.elem(i);
  }
#endif
  dfv1.save_dvector_derivatives(v1pos);
  dfv2.save_dvector_derivatives(v2pos);
  //ierr=fsetpos(gradient_structure::get_fp(),&filepos);
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

void dvcv_dot(void);

/**
 * Description not yet available.
 * \param
 */
dvariable operator*(const dvar_vector& v2, const dvector& cv1)
{
  if (cv1.indexmin()!=v2.indexmin()||cv1.indexmax()!=v2.indexmax())
  {
    cerr << "Incompatible bounds in "
    "prevariable operator*(const dvar_vector& v1, const dvar_vector& v2)"
    << endl;
    ad_exit(1);
  }
  //dvector cv1;
  //dvector cv2=value(v2);
  double tmp=0;

#ifdef OPT_LIB
    int mmin=cv1.indexmin();
    int mmax=cv1.indexmax();
    const double * pt1=&cv1.elem(mmin);
    const double * pt1m=&cv1.elem(mmax);
    const double * pt2=&v2.elem_value(mmin);
    do
    {
      tmp+= *pt1++ * *pt2++;
    }
    while (pt1<=pt1m);
#else
  #ifndef USE_ASSEMBLER
    int mmin=cv1.indexmin();
    int mmax=cv1.indexmax();
    for (int i=mmin;i<=mmax;i++)
    {
      tmp+=cv1.elem(i)*v2.elem_value(i);
    }
  #else
    int min=cv1.indexmin();
    int n=cv1.indexmax()-min+1;
    dp_dotproduct(&tmp,&(cv1.elem(min)),&(v2.elem_value(min)),n);
  #endif
#endif

  dvariable vtmp=nograd_assign(tmp);

  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;

  // The derivative list considerations
  save_identifier_string("yyyy");
  fp->save_dvector_value(cv1);
  fp->save_dvector_position(cv1);
  fp->save_dvar_vector_position(v2);
  fp->save_prevariable_position(vtmp);
  save_identifier_string("uuuu");
  gs->GRAD_STACK1->set_gradient_stack(dvcv_dot);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void dvcv_dot(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("uuuu");
  double dftmp=fp->restore_prevariable_derivative();
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  dvector_position dpos=fp->restore_dvector_position();
  dvector cv1=fp->restore_dvector_value(dpos);
  verify_identifier_string("yyyy");

  dvector dfv2(cv1.indexmin(),cv1.indexmax());

#ifdef OPT_LIB
  double * pc1=&cv1.elem(cv1.indexmin());
  double * pc1m=&cv1(cv1.indexmax());
  double * pdf=&dfv2.elem(cv1.indexmin());
  do
  {
    *pdf++=dftmp* *pc1++;
  }
  while (pc1 <=pc1m);
#else
  for (int i=cv1.indexmin();i<=cv1.indexmax();i++)
  {
    //tmp+=cv1(i)*cv2(i);
    dfv2.elem(i)=dftmp*cv1.elem(i);
  }
#endif
  dfv2.save_dvector_derivatives(v2pos);
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif


void cvdv_dot(void);

/**
 * Description not yet available.
 * \param
 */
dvariable operator*(const dvector& cv1, const dvar_vector& v2)
{
#ifndef OPT_LIB
  if (cv1.indexmin()!=v2.indexmin()||cv1.indexmax()!=v2.indexmax())
  {
    cerr << "Incompatible bounds in "
      "prevariable operator * (const dvar_vector& v1, const dvar_vector& v2)"
    << endl;
    ad_exit(1);
  }
#endif
    double tmp=0;
    int mmin=cv1.indexmin();
    int mmax=cv1.indexmax();
#ifdef OPT_LIB
    const double * pt1=&cv1.elem(mmin);
    const double * pt1m=&cv1.elem(mmax);
    const double * pt2=&v2.elem_value(mmin);
    do
    {
      tmp+= *pt1++ * *pt2++;
    }
    while (pt1<=pt1m);
#else
  #ifndef USE_ASSEMBLER
    for (int i=mmin;i<=mmax;i++)
    {
      tmp+=cv1.elem(i)*v2.elem_value(i);
    }
  #else
    int min=cv1.indexmin();
    int n=cv1.indexmax()-min+1;
    dp_dotproduct(&tmp,&(cv1.elem(min)),&(v2.elem_value(min)),n);
  #endif
#endif
  dvariable vtmp=nograd_assign(tmp);

  gradient_structure* gs = gradient_structure::_instance;
  DF_FILE* fp = gradient_structure::fp;

  // The derivative list considerations
  save_identifier_string("bbbb");
  fp->save_dvector_value(cv1);
  fp->save_dvector_position(cv1);
  fp->save_dvar_vector_position(v2);
  fp->save_prevariable_position(vtmp);
  save_identifier_string("aaaa");
  gs->GRAD_STACK1->set_gradient_stack(cvdv_dot);
  return vtmp;
}

/**
 * Description not yet available.
 * \param
 */
void cvdv_dot(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("aaaa");
  double dftmp=fp->restore_prevariable_derivative();
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  dvector_position dpos=fp->restore_dvector_position();
  dvector cv1=fp->restore_dvector_value(dpos);
  dvector dfv2(cv1.indexmin(),cv1.indexmax());
  verify_identifier_string("bbbb");
#ifdef OPT_LIB
  double * pc1=&cv1.elem(cv1.indexmin());
  double * pc1m=&cv1(cv1.indexmax());
  double * pdf=&dfv2.elem(cv1.indexmin());
  do
  {
    *pdf++=dftmp* *pc1++;
  }
  while (pc1 <=pc1m);
#else
  for (int i=cv1.indexmin();i<=cv1.indexmax();i++)
  {
    //tmp+=cv1(i)*cv2(i);
    //dfv1(i)=dftmp*cv2(i);
    dfv2.elem(i)=dftmp*cv1.elem(i);
  }
#endif
  //dfv1.save_dvector_derivatives(v1pos);
  dfv2.save_dvector_derivatives(v2pos);
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

#ifdef DEBUG
  #include <cassert>
#endif

/** Compute the dot product of two variable type vectors. The minimum and maxium
  legal subscripts of the arguments must agree; otherwize an error message
   is printed and execution terminates.
  \ingroup matop
  \param v1 A dvar_vector, \f$a\f$.
  \param v2 A dvar_vector, \f$b\f$.
  \return A dvariable, \f$z = a\cdot b = \sum_i a_i\cdot b_i\f$  containing
  the value of the dot product of the two arguments.
*/
dvariable operator*(const dvar_vector& v1, const dvar_vector& v2)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int min=v1.indexmin();
  int max=v1.indexmax();
#ifndef OPT_LIB
  if (min != v2.indexmin() || max != v2.indexmax())
  {
    cerr << "Incompatible bounds in "
	 << "dvariable operator*(const dvar_vector&, const dvar_vector&)\n";
    ad_exit(1);
  }
#endif

  double tmp{0};
  double_and_int* pva1 = v1.va;
  double_and_int* pva2 = v2.va;
  for (int i = min; i <= max; ++i)
  {
    tmp += pva1[i].x * pva2[i].x;
  }

  dvariable vtmp=nograd_assign(tmp);

  grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
  DF_FILE* fp = gradient_structure::fp;
  // The derivative list considerations
  //save_identifier_string("bbbb");
  fp->save_dvar_vector_value(v1);
  fp->save_dvar_vector_position(v1);
  fp->save_dvar_vector_value(v2);
  fp->save_dvar_vector_position(v2);
  fp->save_prevariable_position(vtmp);
  //save_identifier_string("aaaa");
  GRAD_STACK1->set_gradient_stack(dvdv_dot);
  gs->RETURN_ARRAYS_DECREMENT();
  return vtmp;
}

/*
 * Description not yet available.
 * \param
 */
void dvdv_dot(void)
{
  DF_FILE* fp = gradient_structure::fp;

  //verify_identifier_string("aaaa");
  double dftmp=fp->restore_prevariable_derivative();
  dvar_vector_position v2pos=fp->restore_dvar_vector_position();
  dvector cv2=restore_dvar_vector_value(v2pos);
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  dvector cv1=restore_dvar_vector_value(v1pos);
  //verify_identifier_string("bbbb");

  int min = cv1.indexmin();
  int max = cv1.indexmax();

#ifdef DEBUG
  assert(min == cv2.indexmin() && max == cv2.indexmax());
#endif

  dvector dfv1(min, max);
  dvector dfv2(min, max);

  double* pcv1 = cv1.get_v();
  double* pcv2 = cv2.get_v();
  double* pdfv1 = dfv1.get_v();
  double* pdfv2 = dfv2.get_v();
  for (int i = min; i <= max; ++i)
  {
    //tmp+=cv1(i)*cv2(i);
    pdfv1[i] = dftmp * pcv2[i];
    pdfv2[i] = dftmp * pcv1[i];
  }
  dfv1.save_dvector_derivatives(v1pos);
  dfv2.save_dvector_derivatives(v2pos);
}

void X_dv_sum(void);

/** Compute the sum of a variable type vector.
  \ingroup matop
  \param v1 A dvar_vector, \f$a\f$.
  \return A dvariable, \f$s = \sum a \f$  containing the sum of the vector.
*/
dvariable sum(const dvar_vector& v1)
{
  dvariable vtmp = 0.0;
  if (allocated(v1))
  {
    int min = v1.indexmin();
    int max = v1.indexmax();
    //dvector cv1=value(v1);
    double_and_int* pv1 = v1.va + min;
    double tmp=0;
    for (int i = min; i <= max; ++i)
    {
      //tmp+=cv1.elem(i);
      tmp += pv1->x;
      ++pv1;
    }

    vtmp = nograd_assign(tmp);

    grad_stack* GRAD_STACK1 = gradient_structure::GRAD_STACK1;
    DF_FILE* fp = gradient_structure::fp;
    // The derivative list considerations
    save_identifier_string("bbbb");
    fp->save_dvar_vector_position(v1);
    fp->save_prevariable_position(vtmp);
    save_identifier_string("aaaa");
    GRAD_STACK1->set_gradient_stack(X_dv_sum);
  }
  return vtmp;
}

/*
 * Description not yet available.
 *
 */
void X_dv_sum(void)
{
  DF_FILE* fp = gradient_structure::fp;

  verify_identifier_string("aaaa");
  double dftmp=fp->restore_prevariable_derivative();
  dvar_vector_position v1pos=fp->restore_dvar_vector_position();
  verify_identifier_string("bbbb");
  int min = v1pos.indexmin();
  int max = v1pos.indexmax();
  dvector dfv1(min, max);
  double* pdfv1 = dfv1.get_v() + min;
  for (int i = min; i <= max; ++i)
  {
    //tmp+=cv1(i)*cv2(i);
    //dfv1(i)=dftmp;
    *pdfv1 = dftmp;
    ++pdfv1;
  }
  dfv1.save_dvector_derivatives(v1pos);
}

/** Compute the sum of a variable type matrix.
  \ingroup matop
  \param v1 A dvar_matrix, \f$A\f$.
  \return A dvariable, \f$s = \sum A \f$  containing the sum of the matrix.
*/

dvariable sum(const dvar_matrix& m)
{
  gradient_structure* gs = gradient_structure::_instance;
  gs->RETURN_ARRAYS_INCREMENT();

  int min = m.rowmin();
  int max = m.rowmax();
  dvariable tmp{0.0};
  if (min <= max)
  {
    const dvar_vector* pmi = &m(min);
    for (int i = min; i <= max; ++i)
    {
      tmp += sum(*pmi);
      ++pmi;
    }
  }
  gs->RETURN_ARRAYS_DECREMENT();
  return tmp;
}
#include <stdlib.h>

#ifdef __TURBOC__
  #pragma hdrstop
  #include <alloc.h>
#endif

/**
 * Description not yet available.
 * \param
 */
 dvar_vector::dvar_vector(int ncl,int nch, [[maybe_unused]] kkludge_object kg)
 {
   va=NULL;
   allocate(ncl,nch);

   #ifdef DIAG
     cout << " Allocating dvar_vector with ptr_address\n  "
         << &va << "  pointing at  " << (va+indexmin()) << "\n";
   #endif
 }

/**
Return a copy of the maximum element in variables vector.

\ingroup misc
\param variables is a dvar_vector
\returns maximum variable
*/
dvariable max(const dvar_vector& variables)
{
  int mmin = variables.indexmin();
  int mmax = variables.indexmax();
  dvariable maximum = variables.elem(mmin);
  for (int i = mmin + 1; i <= mmax; ++i)
  {
    if (maximum < variables.elem(i)) maximum = variables.elem(i);
  }
  return maximum;
}
/**
Return a copy of the minimum element in variables vector.

\ingroup misc
\param variables is a dvar_vector
\returns minimum variable
*/
dvariable min(const dvar_vector& variables)
{
  int mmin = variables.indexmin();
  int mmax = variables.indexmax();
  dvariable minimum = variables.elem(mmin);
  for (int i = mmin + 1; i <= mmax; ++i)
  {
    if (minimum > variables.elem(i)) minimum = variables.elem(i);
  }
  return minimum;
}

#ifdef __ZTC__
  #include <iostream.hpp>
  #if (__ZTC__ < 0x310)
    #include <sstream.hpp>
  #else
    #include <strstream.h>
  #endif
#endif

#if defined(__TURBOC__)
   #include <iostream.h>
   #include <strstrea.h>
#endif

#ifdef __SUN__
   #include <iostream.h>
  #include <strstream.h>
  #define __USE_IOSTREAM__
#endif

#ifdef __NDPX__
   #include <iostream.h>
   #include <sstream.h>
#endif

#include <string.h>
#include <ctype.h>

#ifdef DEBUG
  #include <cassert>
  #include <climits>
#endif

const int MAX_FIELD_LENGTH = 500;

/**
Fill variable vector from values in string s.
\param s should be in {v1, ..., vn} format.
*/
void dvar_vector::fill(const char * s)
{
  const size_t len = strlen(s);
#ifdef DEBUG
  assert(len <= INT_MAX);
#endif
  char *t = new char[len];
  const int n = static_cast<int>(len);
  int lbraces = 0;
  int rbraces = 0;
  unsigned int commas  = 0;

  for (int k = 0; k < n; k++)
  {
    if (s[k] == '{')
    {
      lbraces ++;
      t[k] = ' ';
    }
    else if (s[k] == '}')
    {
      rbraces ++;
      t[k] = ' ';
    }
    else if (s[k] == ',')
    {
      commas ++;
      t[k] = ' ';
    }
    else
    {
      t[k] = s[k];
    }
  }

  if (lbraces == 1 && rbraces == 1)
  {
    unsigned int nch = commas + 1;

    if (nch != size())
    {
      if (nch < size())
      {
        cerr << "Not enough elements to fill vector in "
        "dvar_vector::fill(const char * s)\n";
        cerr << s << "\n";
        ad_exit(1);
      }
      else
      {
        cerr << "Too many elements for size of vector in "
        "dvar_vector::fill(const char * s)\n";
        cerr << s << "\n";
        ad_exit(1);
      }
    }
//   char * field = (char *) new[size_t(MAX_FIELD_LENGTH+1)];
   char* field = new char[size_t(MAX_FIELD_LENGTH+1)];
   char* err_ptr = NULL;

   size_t index = 0;
   size_t length = strlen(t);
   for (int i=indexmin();i<=indexmax();i++)
   {
     char c = t[index];
     while (c == ' ')
     {
       ++index;
       if (index >= length) break;

       c = t[index];
     }
     int field_index = 0;
     while (c != ' ')
     {
       field[field_index] = c;
       ++field_index;

       ++index;
       if (index >= length) break;

       c = t[index];
     }
     field[field_index] = '\0';
     elem(i)=strtod(field,&err_ptr); // increment column counter

     if (isalpha((unsigned char)err_ptr[0]))
     {
       cerr << "Error decoding field "
         << " in dmatrix::dmatrix(char * filename) " << "\n";
       cerr << "Error occurred at element " << i << "\n";
       cerr << "Offending characters start with "
           << err_ptr[0]
           << err_ptr[1]
           << err_ptr[2]
           << err_ptr[3] << "\n";
       ad_exit(1);
     }
     if (elem(i) == HUGE_VAL || elem(i) == -HUGE_VAL)
     {
       cerr << "Overflow Error decoding field "
           " in dmatrix::dmatrix(char * ) " << "\n";
       cerr << "Error occurred at element " << i << "\n";
       ad_exit(1);
     }
   }
   delete [] field;
   field = NULL;
  }
  else
  {
    delete [] t;
    t = NULL;

    if (lbraces != rbraces)
    {
      cerr << "Unbalanced braces in dvar_vector::fill(const char * s)\n";
      cerr << s << "\n";
      ad_exit(1);
    }
    if (lbraces > 1)
    {
      cerr << "Only one level of braces allowed in "
      "dvar_vector::fill(const char * s)\n";
      cerr << s << "\n";
      ad_exit(1);
    }
    if (lbraces == 0)
    {
      cerr << "Missing braces { ... } in dvar_vector::fill(const char * s)\n";
      cerr << s << "\n";
      ad_exit(1);
    }
  }
  delete [] t;
  t = NULL;
}

#ifdef __TURBOC__
  #pragma hdrstop
  #include <iostream.h>
#endif

#ifdef __ZTC__
  #include <iostream.hpp>
#endif

#include <stdio.h>
#ifndef __SUN__
#endif
#include <math.h>

/**
Creates an entry in the gradient structure linked list.
\return Pointer instance of class double_and_int
*/
double_and_int* gradnew()
{
#if !defined(OPT_LIB)
  if (!gradient_structure::_instance)
  {
    cerr << "Error -- you are trying to create a dvariable object"
            " when there is " << endl << "no object of type"
            " gradient_structure in scope " << endl;
    ad_exit(1);
  }
#endif
  return gradient_structure::_instance->GRAD_LIST->gradnew();
}

double_and_int* dlist::gradnew()
{
  dlink* tmp = last_remove();
  if (!tmp)
  {
    tmp = create();
  }
  //  cout << "In gradnew the address of the double * ptr is "
  //       << _farptr_tolong(tmp) << "\n";
  return (double_and_int*)tmp;
}
/**
 * Description not yet available.
 * \param
 */
void gradfree(dlink* v)
{
  if (gradient_structure::_instance)
  {
    gradient_structure::_instance->GRAD_LIST->append(v);
  }
  v = NULL;
}
//prevariable::prevariable(const prevariable& t)
//  {
//     v=t.v;
//     (*v).nc++;
//  }

int traceflag=0;
